arX1v:2107.03072v1 [cs.CR] 7 Jul 2021

ANDROID SECURITY USING NLP TECHNIQUES:

A REVIEW
Sevil Sen Burcu Can
WISE Lab., Dept. of Computer Engineering Research Institute of Information and Language Processing
Hacettepe University, University of Wolverhampton,
Ankara, TURKEY Wolverhampton, UK
ssen@cs.hacettepe.edu.tr b.can@wlv.ac.uk
July 8, 2021
ABSTRACT

Android is among the most targeted platform by attackers. While attackers are improving their
techniques, traditional solutions based on static and dynamic analysis have been also evolving. In
addition to the application code, Android applications have some metadata that could be useful for
security analysis of applications. Unlike traditional application distribution mechanisms, Android
applications are distributed centrally in mobile markets. Therefore, beside application packages,
such markets contain app information provided by app developers and app users. The availability of
such useful textual data together with the advancement in Natural Language Processing (NLP) that
is used to process and understand textual data has encouraged researchers to investigate the use of
NLP techniques in Android security. Especially, security solutions based on NLP have accelerated
in the last 5 years and proven to be useful. This study reviews these proposals and aim to explore
possible research directions for future studies by presenting state-of-the-art in this domain. We mainly
focus on NLP-based solutions under four categories: description-to-behaviour fidelity, description
generation, privacy and malware detection.

1 Introduction

With the advancement of mobile devices and communication technology, mobile devices have become an integral part
of our lives. They provide many useful functions such as the ability to read/write e-mails, indicate nearby facilities,
video conferencing to name but a few. According to [Cisco] {2019}, 5.6 billion people will have mobile devices by 2020,
which is more than the number of people that have electricity (5.3 billion), running water (3.5 billion) and cars (2.8
billion). Furthermore, there have been reported almost 2.5 million available applications (apps) on Android official
market (Google Play) in the second quarter of 2019 [Statista] /2019]. However, the popularity and adoption of mobile
devices and mobile apps also attract attackers in order to harm mobile devices, and steal private information of mobile
users. We still see that mobile malware has continued to increase in scope and complexity [McAfee] [2019].

Unlike traditional application distribution mechanisms, mobile apps are distributed centrally, so mobile markets beside
application package contain application metadata such as application definitions, user scores and reviews. Having a
central app deployment mechanism not only has enriched studies on software engineering, but also has potential in
augmenting security approaches by using non-technical data available in app stores [Martin et al.| [2016]. For example,
while application descriptions could give an idea about the intention of application developers, user reviews could give
some direct information about the experience of users on applications. Even application codes could be considered as a
form of textual data. Natural language processing (NLP) provides a way for understanding and using such textual data
for various reasons including security. It is a new application area of NLP that is accelerated mainly with the availability
of useful metadata on application stores. The main aim of this study is to review such studies that integrate NLP with
Android security, by utilizing any type of textual data provided with apps. With this study, these trends are outlined and
future research directions in this domain are discussed.


A PREPRINT - JULY 8, 2021

In this study, the use of NLP in Android security is explored under four categories: description-to-behaviour fidelity,
description generation, privacy, and malware detection. Description-to-behaviour fidelity part reviews studies that aim
to discover inconsistencies between app behaviour and metadata. In description generation part, studies that aim to
generate app descriptions, privacy policies, explanations of malware, or any other metadata, particularly security or
privacy related text generations are analyzed. Privacy part deals with studies focusing on discovering sensitive user
inputs that could help detecting data leakage in apps. Finally, malware detection part explores the usage of metadata on
malware analysis and detection.

All of these research problems analyzed in this article address either human generated textual data or aim to generate
textual data according to the natural language rules. Therefore, using the methods to understand natural languages,
namely NLP, enables also tackling with the description-to-behaviour fidelity problem or malware detection by using
any metadata of apps that are written in a natural language. Security-related research could consider the problem as a
keyword searching problem [2015]. For example, a keyword search performed in an
application’s description can predict that there 1s no sufficient detail in the description regarding the READ_CONTACTS
permission. However, the absence of a keyword does not necessarily imply that such meaning does not exist in the
description. There could be semantically related other words that could lead to a similar meaning and if we consider
the vocabulary coverage of a natural language, we can conclude that it is nearly impossible to cover all the intended
keywords. Meaning is yet more than lexical meaning that consider’s only the meaning of a single word. Understanding
is a lot more contextual than this. Therefore, most of the tasks require more natural language understanding rather
than just searching for some keywords. Some studies have already shown that
involving more semantics in security-related problems also enhances the success of the studies. Semantics is only one
dimension in NLP and other dimensions (such as syntax) that enables to understand a language will be also reviewed in
the following section (see Section{2).

The paper is organized as follows. The next section introduces the basic concepts in Android security and NLP. The
current state-of-the-art on using NLP for Android security is summarized in four sections, namely description-to-
permission fidelity, description generation, privacy and malware detection in Section }3}{6} Each section separately
includes discussion of the related studies for addressing corresponding problem and explores possible future research
directions. Section|/|shortly gives traditional approaches in Android security. Section|8]discusses how these approaches
could be complemented with the NLP-based approaches reviewed in this study. Moreover, the strengths and weaknesses
of the proposed approaches from the NLP point of view are discussed in this section, and the possible future directions
for researchers are presented. Finally, Section ]includes concluding remarks.

2 Background

In this section, background information on Android security, particularly permissions mechanism and NLP will be
covered. Android, which is based on a modified version of the Linux kernel, is still among the most targeted platforms
by attackers. Android security is mostly related to protect mobile devices and users from harmful activities carried out
through apps. One of the basic Android security mechanisms is isolating these app resources by assigning each app a
unique user ID and running it in a sandbox. Another important mechanism is to control access to user sensitive data and
to certain system resources by using permissions, which is described in details below. Android has been modifying its
architecture to improve security, but that is only beneficial to users who download the latest version of Android, which

is rarely the case |Symantec\|2017].

2.1 Permissions

Permissions are one of the key points of Android security mechanism. The permissions required by app must be listed
in application’s manifest file. According to their protection level, Android permissions are generally divided into two
groups: normal and dangerous permissions. Since normal permissions cover access areas of an application that are
outside the app’s sandbox [Android] [2020], they do not need to be granted by users. On the other hand, users have to
grant explicitly dangerous permissions because such permissions request to access users’ sensitive data such as contact
lists, call logs or certain system features such as camera, microphone . The way Android asks users
to grant dangerous permissions has changed with Android 6.0. Before Android 6.0, all dangerous permissions had
to be granted at the installation time. In Android 6.0 and in the higher versions, users are asked to grant dangerous
permissions at runtime.

Dangerous permissions in Android are listed in Table[I] Users expect explanations for the usage of such permissions in
app descriptions or privacy policies, since such permissions could affect the privacy of users or the normal operation

of the system [Android] |2020]. This is called description-to-permission fidelity in the literature [Qu et al.||2014].


A PREPRINT - JULY 8, 2021

Table 1: Dangerous Permissions [Android}|2019b

Group Permissions
Calendar READ_CALENDAR
WRITE_CALENDAR

Camera CAMERA
Contacts READ_CONTACTS
WRITE_CONTACTS
GET_ACCOUNTS
Location ACCESS_BACKGROUND_LOCATION
ACCESS_FINE_LOCATION
ACCESS_COARSE_LOCATION
ACCESS_MEDIA_LOCATION
Microphone RECORD_AUDIO

Phone READ_PHONE_NUMBERS

READ_PHONE_STATE
CALL_PHONE
READ_CALL_LOG
WRITE_CALL_LOG
ADD_VOICEMAIL
USE_SIP
PROCESS_OUTGOING_CALLS
ANSWER_PHONE_CALLS
ACCEPT_HANDOVER
Sensors BODY_SENSORS
ACTIVITY_RECOGNITION
SMS SEND_SMS
RECEIVE_SMS
READ_SMS
RECEIVE_WAP_PUSH
RECEIVE_MMS
Storage READ_EXTERNAL_STORAGE
WRITE_EXTERNAL_STORAGE

Since permissions are one of the important aspects of Android security and, dangerous permissions are expected to be
explained in app metadata, the NLP studies on Android security are mainly shaped around permissions.

2.2 NLP

Natural language processing (NLP) is concerned with understanding human languages through computer programs
and therefore addresses interactions between humans and computers. NLP involves tasks from the linguistic levels of
a language, such as part-of-speech (PoS) tagging, stemming, parsing, and semantics to better understand the natural
languages. Here, we will not mention about all the tasks in NLP, but cover some of them, which are frequently utilized
in the security or privacy fields, therefore we aim to ease reading of the article for the readers who are outside the NLP
domain.

There are several linguistic levels of a natural language (see the NLP pyramid in Figure [ip. The fundamental levels are
syntax and semantics. Syntax defines the rules of a language that describe the word order in a given sentence and the
functionalities of the words in that sentence. Part-of-speech (PoS) tagging is the task of assigning a syntactic category
to each word in a given sentence depending on its syntactic role in that context, such as a noun, an adjective. For
example, it could be crucial to determine the meaning of contact depending on its PoS tag (i.e. if it is a noun then it
possibly refers to violations in regard to contact lists). Dependency parsing gives a more detailed syntactic structure
of a sentence along with the relationships between the words in that sentence. For example, secure is a modifier and
applications is the head of this modifier in the noun phrase secure applications, which is typically the subject or the
object of a verb in the sentence leading to a verb phrase, such as installing secure applications. Dependency parsing
is one of the frequently utilized tasks in security and privacy. For example, in the description-to-permission fidelity
problem, permissions are usually verb phrases and need to be extracted from descriptions or reviews automatically

2014] Wang et al.||2019b], or sensitive inputs are usually noun phrases in privacy policies [Yu et al.|/2017].

Language is usually sparse due to different and usually informal writing styles of different users (i.e. user reviews),
or due to different forms of the same word (having inflectional/derivational morphemes at the end of the word) such
as contacting and contacts. Those differences are standardized to reduce the number of features extracted from data.
Stemming is a common way to reduce word forms into a single form by filtering out inflectional morphemes from the
end of the words, which is related with the morphology level (Figure[I).

Semantics is concerned with the meaning of a word in a given context and it is usually coupled with syntax. For
example, the meaning of the word contact is only obvious, if we know that it is either a verb or a noun. Therefore, most


A PREPRINT - JULY 8, 2021

Pragmatics

Semantics

Syntax

Morphology

Figure 1: NLP Pyramid

semantic related problems (i.e. permission extraction from descriptions or detection of sensitive words in a given user
input) involve also syntactic parsing or PoS tagging as a preprocessing task. Meaning can be represented in different
forms. Lexical dictionaries such as for English are very common to obtain semantic information of a
word through its synonyms and hypernyms/hyponymg!| WordNet has been used in various problems such as description-
to-permission fidelity, or privacy for especially finding the synonyms of words. Recently, the concept of neural word
embeddings has risen with the neural model called word2vec where the representations (that
involve semantics of words) of words in similar contexts (thereby having similar meanings) are urged to be located
closer to each other in the vector space, thereby having similar word embeddings. Word2vec |Mikolov et al. is
based on a two layer neural network where the hidden layer weights are extracted to be used for the word representations.

Word2vec has also been used in description-to-behaviour fidelity
[2019b], description generation [Liu et al-]/2018}, privacy ER aa the similarities between the
meanings of words/phrases, and malware detection (e.g. apk2vec [Narayanan et al.| adopts the same architecture
as word2vec where the app representations are obtained). Moreover, some studies [Slavin et al.|
build their ontologies to learn the semantic relations between concepts.

The top level in the NLP pyramid corresponds to pragmatics, which handles the context in the text as a whole by again
concerning with the semantics with a deeper context. To our knowledge, this level has not been studied under Android
security yet.

3 Description-to-behaviour Fidelity

One of the important usages of app metadata is to discover inconsistencies between app behaviour and app metadata. For
instance, if the functionality of apps is given in sufficient detail in their descriptions, then the requirement of requested
dangerous permissions could be well understood. This is defined as description-to-permission fidelity (Qu et al.|/2014}.
From the security point of view, the lack of an explanation about the requirement of a dangerous permission in app’s
description creates a suspicion. Such suspicious apps could then be subject to analysis by more resource-intensive
techniques. It is a new application analysis approach that could complement traditional analysis techniques. Moreover,
the proposed approach could assist users before installing apps or app developer could use it in order to improve their
descriptions and create user-understandable descriptions. Lastly, it could be used the other way around by generating

semantic permissions based on descriptions | Wang and Chen\|2014], if descriptions well represent the functionality of
an app.

Although most studies in the literature focus on finding semantic relatedness between permissions and descriptions,
recent advancements employ also user reviews and privacy policies for extracting useful information. App descriptions
have a limited space, so user reviews and privacy policies could consist of more information about security and privacy
of applications. For instance, while user reviews could give information about the positive/negative experience of users
about dangerous permissions, privacy policies focus more on the usage of sensitive and private data whose access
requires dangerous permissions. Moreover, since privacy policies generally contain simple sentence structures due to

‘A hyponym’s meaning is involved in a hypernym’s meaning. Contact can be considered as the hypernym of address and vice
versa.


A PREPRINT - JULY 8, 2021

developers being advised to do so, NLP techniques are promising on such texts. Moreover, approaches for finding
inconsistencies in privacy policies are recently proposed and explored here.

To sum up, in this study, approaches on description-to-behaviour fidelity are covered under the following four sections:
descriptions, user reviews, privacy policy, and static/dynamic analysis. Most of the studies focus on metadata for
understanding the purpose of a permission. However, the reason of an app to access sensitive data could also be obtained
by analyzing the app’s code or runtime behaviours. Therefore static and dynamic analysis techniques combined with
NLP-based techniques for this purpose are also included.

3.1 Descriptions

Permissions are used by apps for a variety of reasons. However, while the usage of a set of dangerous permissions could
be understandable for an anti-virus solution, the usage of the same set of permissions in a daily horoscope app could be
an indication of malicious intention. For such apps which use dangerous permissions, the developer is expected to state
the requirement of dangerous permissions in its description. While anti-virus apps mentioned above are expected to do
so, the malicious horoscope app could hide that information from its description. Even though, users are asked explicitly
to grant dangerous permissions during installation or runtime, most users are not conscious or aware of such requests
(Felt et al.| [2012], so app descriptions could be a more preferable choice for naive users. This is the main motivation
behind the studies below, so they propose automatic (fully or half-fully) approaches for finding inconsistencies between
descriptions and requested permissions.

The first study on assessing description-to-permission fidelity is carried out by [Pandita et al.||2013]. The framework
called WHYPER (WHP PERmissions) uses NLP in order to identify sentences that describe the need for requested

permissions and, compares the proposed approach with a keyword-based approach. In the keyword-based method, a
word can have different meanings in different sentences. On the other hand, since WHYPER proposes a semantic-based
approach, it performs much better than the keyword-based approach. At first, WHYPER converts each sentence into their
First-Order Logic (FOL) representations after preprocessing the sentences (detecting sentence boundaries, handling
abbreviations, etc.) in app definitions. Then, it creates semantic graphs of permissions from application programming
interface (API) documents, and checks whether these semantic graphs associate with description sentences or not. The
success of the proposed framework depends on being sufficiently comprehensive of semantic graphs of the permissions.

While WHYPER is proposed as a means to alleviate the shortcomings of a keyword-based approach (confounding effects
that a word can have different meanings and semantic interference that describes the usage of a permission without using
a particular word), proposes a keyword-based approach called ACODE due to being lightweight
for large datasets, because ACODE does not require labelling app descriptions. By combining static analysis and text
analysis, ACODE performs better than the keyword-based approach used for comparison in WHYPER
and produces comparable results with WHYPER. Relevance weights inspired from the information retrieval field
are used for extracting the keywords, which are used to match queries with relevant documents. In this study, due to the
lack of labelled dataset, descriptions that involve permission statements are regarded as relevant documents, and the rest
is regarded as irrelevant documents. Keyword extraction is performed by ranking the words based on the relevance
weights, and furthermore combining the results with the code analysis. Unlike other studies in the literature, it can be
applied to different languages without much effort and change.

AUTOCOG also employs NLP techniques in order to relate descriptions with permissions 2014]. Since
API documents are not sufficient for having the complete semantic patterns of some permissions, only descriptions
are employed in order to extract semantic information in AUTOCOG. Semantic relatedness between descriptions
and permissions is measured using Explicit Semantic Analysis (ESA). Instead of using a dictionary based corpus
like WordNet as done in WHYPER, ESA uses a large knowledge base (i.e., Wikipedia) in order to
create vectorial representations of the text. AUTOCOG extracts noun phrases from descriptions and creates a semantic
relatedness score matrix among them using ESA. Frequent noun phrases are grouped together and a relatedness
dictionary is created between the noun phrases (np). To relate permissions with noun phrases, correlation between
noun phrases and permissions are defined using a threshold value. Those noun phrases are extended by pairing them
with related np-counterparts. Therefore, each permission has a list of related noun phrases and np-counterpart pairs.
Given a description, AUTOCOG extracts noun phrases and np-counterpart pairs and then identifies whether the need for a
permission is stated in the description or not. While AUTOCOG is a fully-automated approach and performs much better
than WHYPER, it could extract semantic relationships that may not actually exist, which may lead to false positives.

In AC-NET (Assessing Consistency based on Neural Network) [Feng et al.|/2019], unlike Whyper [Pandita et al.|/2013
and Autocog [Qu et al.|/2014], semantic representations of words are obtained from word embeddings. Word2vec

| Mikolov et al.||2013al is trained on Android app descriptions collected from Google Play. Therefore, the word
embeddings used in AC-NET have domain-specific features. Once the word embeddings are learned through the


A PREPRINT - JULY 8, 2021

word2vec model, Recurrent Neural Networks (RNNs) [Hochreiter and Schmidhuber' are used for generating the
compositional meaning of a given decsription by processing each word at a time and gives the overall meaning (i.e.
vectorial representation) of the given sentence in a description. Compositional semantics states that the meaning of a
phrase or a sentence is obtained from the composition of the meaning of each word in a sequence. In AC-NET, Gated
Recurrent Unit (GRU) [Cho et al.||2014], a type of recurrent neural network, is used for the vanishing gradient problem
in the standard recurrent neural networks for the long sequences. The word2vec trained embedding of each word in
a description is is fed through a bidirectional GRU, where one GRU processes the sentence in the forward order and
another GRU processes the sentence in the reverse order, and finally the outputs of each GRU is concatenated to have a
compositional representation of the given sentence. A probability of the given sentence implying the given permission
is obtained by applying a sigmoid function on the output representation of the sentence. The current state-of-the-art
results are obtained from this model due to the performance of both using domain-specific word embeddings and
recurrent neural networks. In a very recent study called DesRe [Alecakir et al.}|2021], two models that use also GRU are
proposed. Here, the attention mechanism is also employed for the problem for the first time in the literature. While the
first model identifies permission sentences in a description, the document-based model based on hierarchical attention
network represents an app description as a whole differently from other studies in the literature. By using the attention
mechanism, the permission statement words or sentences in app descriptions are found and shown to have positive
effects on the results. Moreover, the study introduces a new dataset called DesRe [WISE Lab} [2019], which includes
app descriptions and five user reviews declared to be most helpful by other users for each application.

3.2 User Reviews

AutoReb introduces the concept of review-to-behaviour fidelity in Android apps as the first work that
explores employing the user review information to detect any security related behaviour of an app. It is a keyword-based
approach where the keywords are manually extracted by analyzing the co-occurrence of the words with the initially
defined two-word set ({ security, privacy}). Similar to Whyper [Pandita et al.|/2013}, an information retrieval method
called query expansion is used to find the relevant reviews that include security-related content. Once the reviews are
expanded, Bag of Words (BOW) features are extracted from those reviews to be used in classification training. Spare
linear Support Vector Machine (SVM) is used for training the model for the multi-label classification to assign a given
review to one of the following security behaviour categories: spamming, financial issue, over-privileged permissions,
and data leakage. Once the security behaviour is annotated using the query expansion method, a crowdsourcing method
is used to finalize the label of each app because there could be conflicts among different reviews written for the same
app. The labelling provided by the SVM classifier for each review is regarded as crowdsourcing opinions gathered
from different users. Expectation Maximization algorithm (EM) is used along with Maximum Likelihood Estimate
(MLE) to aggregate the labels obtained from the classifier with the application level behaviour, thereby making a
binary prediction for each label. The study proves that user reviews play an important role in analyzing the application
behaviours, although the user expectations could be different and the corresponding reviews are quite personal.

A very recent study | Wang et al.|/2019b] proposed to find permission indications from user reviews, differently from
the previous studies. The framework called SmartPI includes four phases: data collection, reviews selection, reviews

clustering, and permission inference. In the data collection phase, apps, app descriptions, permission docs, API docs
and user reviews are collected. Representative words of permissions are extracted by using these documents. Firstly,
noun or noun phrases and word pairs (verb, noun) are extracted from permission documents and API documents,
then these representative words are enhanced in two ways. In the first way, synonyms of those words are extracted
from WordNet [Miller] {1995}. Secondly, co-occurence words of representative words are extracted from descriptions
according to their co-occurrence frequencies. In review selection phase, both user reviews and permission-representative
words are formed as feature vectors using word2vec [2013a]. Then, each review’s similarity to the
permission-representative words are calculated by using cosine similarity. According to the estimated similarities,
funtionality-relevant user reviews are selected. Reviews are grouped into 10 (number of permissions) clusters using
Biterm Topic Model (BTM) [Cheng et al.|/2014]. Each cluster represents a permission. Finally, a review is mapped to a
cluster in the permission inference phase. The proposed study is compared with AUTOCOG [Qu et al.|/2014], and shows
slightly better results. Furthermore, two approaches are evaluated on 200 apps randomly collected from Google Play.
This test supports the hypothesis of the study that user reviews are more representative than app descriptions.

Another recent study |Alecakir et al.||2020] also employs the user reviews for the description-to-permission fidelity
problem. In that study, the most helpful reviews (rated as five stars) are involved in detecting any inconsistency between

descriptions and the application behaviour. The model is trained by using the annotated description dataset called
DesRe [WISE Lab] |2019], and it incorporates the reviews during testing. To this end, either the description or both the
description and reviews are used in testing. If the description is sufficient to claim that there is not such an inconsistency
between the description and the permission, and the permission is already mentioned in the description, then the reviews
are not used. However, in the lack of a strong claim for such an inconsistency, the reviews are employed along with the


A PREPRINT - JULY 8, 2021

descriptions in testing. The model is based on an RNN structure similar to [Feng et al.|/2019], but uses Long Short
Term Memory Network |Hochreiter and Schmidhuber}||1997], which is also another type of recurrent neural network.

The results show that using reviews improves the detection capability of the model for particular permissions.

Last but not least, [Nguyen et al.}|2019] analyze the user reviews, but unlike the previous work the authors try to find the
connections between security and privacy-related reviews (SPR) and security and privacy-related app updates (SPU).

Once the reviews are collected from Google Play, a keyword list is generated half manually, and SVM is used as a
classifier to categorize the reviews either privacy, security-related or not by employing the character n-grams of words
in the reviews that are already stemmed. An app’s updates and relevant security or privacy-related changes are obtained
by static code analysis on different versions of the app that are released on the date of reviews. Finally, SPR and SPU
belonging to different versions of the app are mapped. The results show that majority of the SPR is a predictor for SPU.

3.3. Privacy Policy

Personal and sensitive user data is defined but not limited to by Google as “personally identifiable information, financial
and payment information, authentication information, phonebook, contacts, SMS and call related data, microphone

and camera sensor data, and sensitive device or usage data” [Google Play||2019b]. Google expects developers to be
transparent about disclosing the collection, use, and sharing of such personal and sensitive data, and limiting the use of

the data to the purposes disclosed, and the consent provided by the user [Google Play||2019b]. Such information is
expected to be given in privacy policies and Google announced that it is going to remove applications which do not

comply with Google’s User Data Policy starting from March, 15 2017 [Caira and Ey||2019]. This privacy and security
enforcement by Google and the character limitation on app descriptions make the usage of privacy policies eligible
for Android security. Moreover, the guidelines for developers suggest using a simple language in privacy policies in
order to be understandable by various users. Hence, such documents could be easily processed by NLP techniques. For
example, a recent study is able to extract general sentence structures in Android privacy policies successfully
and verbs in these structures conform to common privacy policy keywords [Anton et al.]/2004].

Some recent studies explore the use of privacy policy for enhancing the description-to-behaviour fidelity
[2017] /2016b]. TAP Verifier claims that descriptions are not sufficient for assessing the description-
to-behaviour fidelity, since developers might not declare all usages of sensitive data in app descriptions that have a
character limit. Privacy policies could give more information about that. The new update on the User Data Policy of
Google, which forces developers to provide privacy policy [Caira and Ey||2019], supports this hypothesis. TAPVerifier
employs a two-stage analysis in order to complement other studies such as Autocog and decreases
their false positives: privacy policy analysis, code and permission analysis. While privacy policy analysis extracts the
necessity of a requested permission from the app’s privacy policy, code analysis extracts the permissions used in the
code by using PScout [Au et al.}/2012], which maps API calls with permissions. The permissions of the third party
libraries are also included in this study as one of the enhancements of the previous study of the same authors

2016).

The privacy policy analysis of TAPVerifier [Yu et al.)
splitting privacy policies into sentences by using [NLTK' , the dependency parse trees of those sentences are
generated by using the Stanford Parser along with the PoS tags of the words within each sentence.
Then sentences are mapped to one of the 9 manually defined semantic patterns. These are structure(s) of the actions
that need to be mentioned in a privacy policy such as data collection, data access, data disclose. If a sentence cannot
map to any semantic pattern, it is removed. Then, resources in the extracted sentences are determined by extracting
noun phrases in the unconditional clauses. Co-reference resolutio Plis also applied to find the entities that the pronouns
point to, which shows that it improves the overall performance. If the sentence that the resources are referenced in is a
negative one, in other words if it contains negative words such as no, unable, hardly, then such resources are removed,
since it means that those resources are not referenced in any action in the app. Finally, the resources are mapped to
resources of permissions, which are defined by analyzing the permission’s description and the documents of APIs that
are matched by using PScout [Au et al.|/2012]. If the similarity of resources to the resources of permissions, which is
calculated by using ESA [Gabrilovich and Markovitch| a method that gives a vectorial representation of text on
WordNet exceeds a predefined threshold, it means that the privacy policy includes an indication of the requirement of
that permission. Please note that TAPVerifier also analyzes the privacy policies of the third party libraries.

PPChecker [Yu et al.|}2016a] uses NLP for identifying the problems in privacy policy, such as incomplete privacy
policies that lack the details related to the app behaviours, incorrect privacy policies that conflict with the app behaviour,

and inconsistent privacy policies that conflict with the third party libs’ privacy policies. The authors use the pre-defined
verb categories that are used in privacy policies such as collect, use, retain, and disclose verb groups [Breaux et al.|

largely relies on NLP techniques. After preprocessing and

°Co-reference resolution is the task of detecting expressions in a sentence that refer to the same entity.


A PREPRINT - JULY 8, 2021

2014 2013). Similar to TAPVerifier [Yu et al.|/2017], text is first split into sentences using NLTK and
sentences are parsed by Stanford Parser 2010a] to extract the dependency relations between the phrases in

each sentence. A bootstrapping mechanism is used to automatically find any pattern in the privacy policies by giving
the seed pattern SVO (subject-verb-object) initially. All the matched sentences with this pattern are collected and
the subjects and objects in those sentences are also collected. Then new patterns are extracted by using the collected
subjects and objects in the dependency trees. Therefore, this study improves upon TAPVerifier by
automatically generating the patterns. The patterns are ranked by using the number of sentences that can match the
pattern. Finally, sentences are selected by using the generated patterns in the previous step. Similar to TAPVerifier
let al.|/2017}, negation analysis is also performed to detect the negative sentences. However, in this work a negative
word list is also employed. Information elements are extracted from the selected sentences that include the main verb,
subject, and the object. A constraint is also used to remove the sentences that are conditional on an action, such as if you
.... The system performs static code analysis and description analysis by using AutoCog [Qu et al.| . The model
gives a high precision of detecting suspicious privacy policies. It also discovers inconsistencies between descriptions
and privacy policies from the point of permission view.

[Slavin et al.|/2016] detect privacy policy violations by creating a privacy-policy-phrase ontology and by mapping
the API methods to the phrases in privacy policies. First, API terminology is extracted by finding the phrases in the

API documents and having those phrases mapped to the API method names by two investigators. Second, a privacy
policy lexicon is built manually by a group of investigators. Finally, an ontolog Plis constructed again by a group of
investigators manually to define the relationships between the terminology extracted from the API documents and the
terminology used in the privacy policies. Therefore, using the method names it would be possible to infer the privacy
policy terms that should appear in the policy of the application by creating a mapping between the policy terms and the
API methods using the ontology. To detect the privacy policy violations, first all words in a given privacy policy is
lemmatized‘] Then, the lemmatized words and the phrases in the ontology are mapped to find a list of API methods,
where the rest of the API methods which do not appear in the privacy policy as a mapping in the ontology implies a
violation in the privacy policy.

MAPS [Zimmeck et al. gives some interesting statistics about the privacy practices of the Android applications
in Google Play. According to their analysis, only 50.5% of apps have privacy policy links on their Google Play Store
pages. Moreover, MAPS analyzes the privacy policies by tackling the problem as a classification task. TF-IDF vectors
are defined with Boolean values, whether a string exists in the policy statement or not and they are classified by SVC
classifier. The classes state whether a policy belongs to a IstParty or a 3rdParty, or a data type such as Location is
specified in the privacy policy or not, or even whether a privacy practice is stated in the privacy policy or not (e.g. “Our

app accesses the location data.”). The classification results [Story et al.|}2019] are on a high range of negative F1 scores
and the authors suggest an overall improvement upon the state-of-art.

3.4 Static/Dynamic Analysis

Based on the observation that users cannot understand the purpose of permissions based only on descriptions, a recent
study focuses on inferring this information from app’s code and behaviours [Wang et al.||2017al. In the static analysis,
two types of features are extracted from the code: app-specific features that include permission related APIs, Intents,
Content Providers and text-based features. Text-based features are extracted from identifiers (package, class, method
and variable names) in the code. TF-IDF vectors of the word roots in the identifiers that are obtained after pre-processing
identifiers are taken as text-based feature vectors. All features are collected from custom code, then given to classifiers
for assigning apps to one of the categories of purposes of the following two permission uses: contacts and location.
Since supervised learning techniques are employed, an application dataset is constructed and the purpose of these
permissions’ usage is manually labeled. The results show that text-based features are powerful enough for understanding
the purpose of the permission’s use, app-specific features are found to supportive. Third party libraries used by apps are
taken into account in dynamic analysis. If a sensitive data flow is used by a well-known third party library, its purpose
is directly matched with that library. Otherwise, text-based features from the call stack are extracted and used as in
the static analysis. It is shown that static and dynamic analysis could cover different scenarios and produce over 90%
accuracy by complementing each other.

3An ontology is a formal definition of entities and the relationship between those entities. Here, the entities refer to the phrases
obtained from either the API documents or the privacy policies.

“Lemmatization is similar to stemming, however the dictionary form of the word needs to be produced during lemmatization
whereas only the suffixes are removed from the end of the word during stemming. For example, the stem of the word studies is studi,
whereas the lemma form is study.


A PREPRINT - JULY 8, 2021

Privacy Policy

Figure 2: Ratio of Metadata Types in Description-to-Permission Studies

3.5 Discussion

Since 2015, researchers use app descriptions for finding the purposes of dangerous permissions usage in apps and,
produce promising results by using NLP techniques. Especially, studies which aim to find semantics through a large

corpus (such as word2vec [Mikolov et al.||2013al], etc.) and deep learning techniques produce the best results [Feng et al.)
2019}|Alecakir et al.}/2021]. Even though most of these studies only use descriptions for extracting the requirement of

a permission as shown in Figure [2| enhancing these approaches with the usage of privacy policies and user reviews
produce promising results in recent studies. Since privacy policies present information about the usage of sensitive
data directly in a simple format, we could see more applications of extracting information from privacy policies by
using NLP techniques in the future. While the proposed approaches analyze privacy policies on market stores, in-app
privacy policies could also be considered [Yu et al.| . User reviews are also shown to provide useful information
about permissions . Besides unsupervised techniques, the real effects of user
reviews could be observed by introducing labeled datasets that include user reviews. Third party libraries are other
resources that could be explored for the usage of dangerous permissions in future studies. The positive effects of using

these libraries on decreasing false positives are underlined in [Zhang et al.||2018a]. A recent analysis on third party
libraries also claim that the gap between app descriptions and requested permissions is resulted from the extensive

use of such libraries in ee [2017]. Moreover, it is shown that some apps could use more than 20
libraries [|PrivacyGrade and more than 60% of subpackages in the code are from third-party libraries
. To sum up, other metadata such as privacy policies, user reviews, third-party library documents needs

urther investigation for the problem in the future. The effects of the quality of such resources on the performance
of proposed approaches is open to research. Researchers could evaluate and compare their proposals by using recent

public datasets such as AC-NET [Feng et al.|/2019] and DesRe WISE Lab}|2019]. Last but not least, the correlation
between such resources and the code could be explored through semantics (e.g. [Yu et al.|/2018]).

Besides metadata, app code and behaviours could be analyzed for the problem 2017al. A recent study
shows that text-based features extracted from the code or the call stack helps finding the reasons of permissions usage in
an app. Furthermore, such studies could be used for not only pinpointing the usage of a permission but also proving the
requirement of a permission usage declared in app description or in other metadata. This area needs more investigation.
Static/dynamic analysis both on custom code and third-party libraries should be considered. While the purpose of a
permission usage could be too coarse-grained or fined-grained depending on the technique (static and dynamic analysis

respectively) used in [Wang et al.||2017al, this could be further investigated in future studies.

4 Description Generation

This section covers studies that are proposed to automatically generate security related texts for users such as descriptions,
privacy policies, permission explanations, malicious behaviour by using Natural Language Generation (NLG) techniques.
NLG is the task of converting any structured or unstructured data into a natural language text. Although template-based

methods have been excessively used for the problem [Reiter and Dale|/1997 2003], statistical methods
Langkilde}||2000}|Bangalore and Rambow} |2000}/Cahill et al.|[2007] and recently neural network based encoder-decoder

models [Qian et al.|/2017 2017 2017], autoencoders [|Cao and Clark\|2017] have also been
used in NLG.

DescribeMe [Zhang et al.||2015] aims to generate descriptions using NLG techniques by explaining any security or
privacy related behaviours including permission requests. First, the security behaviour graphs are constructed from

a static code analysis. Second, the graph size is reduced with subgraph mining by discovering frequent subgraphs
that are peculiar to some specific security behaviours. Eventually, those graphs are converted to natural language text


A PREPRINT - JULY 8, 2021

by traversing the vertices in the graphs and converting each path into a sentence based on manually defined English
grammar rules under Extended Backus-Naur form (EBNF). Although the results are promising, the number of false
negatives is very high as a result of the static code analysis. As the authors note, this could be improved by plugging
into more advanced analysis tools. From the description-to-permission fidelity perspective, DescribeMe seems to fail to
describe some permission requests because some permissions cannot be resolved, few permissions are not associated
with the API calls, and only some permissions are correlated to certain API parameters.

|Chen et al.|/2016] applies text mining on human-authored reports by malware analysts and produce explanations of
unwanted behaviours in malware using those reports. Therefore malware behaviours are explained in natural language.

In the approach, L-1 Regularized Logistic Regression is employed as a linear classifier for malware
detection by using permissions, actions and API calls as input features. Then, a feature set is defined by obtaining
the negative weights from the classifier that indicates an unexpected behaviour, whereas a positive weight indicates a
normal behaviour. Based on Beam Search algorithm, the authors design an algorithm to find a subset of the keywords
that covers malware instances by ranking them with their TF-IDF weights. Final list of keywords are used to find
sentences that include the keywords in malware descriptions and they are ranked by using the cosine similarity between
the TF-IDF vectors of the sentences. Automatically extracted description sentences are promising, however those
sentences are automatically extracted from the human-authored text rather than being automatically generated as in
DescribeMe [Zhang et al.|[2015]. Moreover, the results of the malware behaviour classification show that DescribeMe

can select the features more accurately compared to Drebin [Arp et al.}/2014].
Similar to DescribeMe [Zhang et al.||2015]], PRESCRIPTION [Wu et al.||2019] aims to generate app descriptions

from security and privacy perspectives. However, unlike DescribeMe, PRESCRIPTION aims to generate personalized
descriptions for different user types. For this purpose, the model learns the user’s concerns through their mobile
permission changes, where a denied list of permissions are regarded as user’s concerns. Then, the users are categorized
based on their personalities according to the Big Five Personality model [2008]. For the classification, a
questionnaire is published online and a correlation is discovered between the application categories and user types.
Moreover, the linguistic preferences are also investigated from different user categories by analyzing the word types
used frequently by each user category (such as positive words are used more often by extravert users). Finally, the text
is generated based on the user’s concerns and the linguistic preferences. During generation, Deep Syntactic Structures
(DSyntS) are used to generate syntactic patterns, where the user-specific parameters help
to choose the right pattern for a given user category. The model gives promising results from various perspectives,
such as semantics correctness, readability, personality judgement, and system efficiency. Moreover, the generated

descriptions are better than that of Drebin [Arp et al.|/2014] in terms of readibility.

CLAP (Collaborative App Permission Recommendation) is a recommender system that recommends
a list of potential requirements for the permission explanation. The framework first finds the similar apps to a given app
by using an interpolation between the similarities of the descriptions, titles, permissions, and categories. In order to
assess the similarities between descriptions, once the stop words and background sentences are removed, the remaining
text is stemmed, and unigrams/bigrams are extracted. A text retrieval method called Okapi BM25
is used to learn the scores between the description of the current app and the other apps’ descriptions in
the dataset. Word2vec is used to estimate the semantic similarity between the titles, the Jaccard
distance is used to assess the similarity between the permissions, and the cosine similarity between the TF-IDF weighted
vectors of the categories is used to estimate the category similarity. In order to identify the permission-explaining
sentences in a description, Stanford PCFG parser is used to break the sentences at the
conjunctions and verb phrases are extracted to find a set of candidate sentences. The sentences that address the given
permissions are found by pre-defined rules based on PoS tags and keywords. Once the explaining sentences are selected,
the recommending sentences are chosen by using majority-voting principle on the descriptions that are summarized

using a text summarization algorithm called TextRank |Mihalcea and Tarau\|2004]. The results show that CLAP can

recommend relevant sentences for permission usages.

Unlike the other work, AutoPPG generates privacy policies for Android apps by using static code
analysis and NLP techniques. It aims to generate easy-to-understand texts that inform users about how their information
will be collected, used and disclosed. Fist, API documents are analyzed in order to identify personal information
used by APIs. ESA is used to compute the semantic relations in the text. Then,
by employing static code analysis, invoked sensitive APIs and their mappings to personal information are extracted.
The information about under which conditions these APIs are invoked and how the personal information is processed
(e.g. stored, transferred) are also obtained in this step. Finally, NLP techniques such as generating sentences based
on a template, removing sentences with the same meanings, rearranging sentences in a paragraph according to their
importance are employed to generate privacy policies.

10


A PREPRINT - JULY 8, 2021

4.1 Discussion

The studies under NLG with the security or privacy concerns could be categorized into description generation, privacy
policy generation, and malware behaviour explanations. The main concern in the description generation research is
the lack of the security related information in the description data. Studies such as DescribeMe
fills this gap by generating security-centric descriptions that will help the app user to be more aware of any security
issues of an app, such as the permission requests. A recent study PRESCRIPTION [Wu et al. advances this even
further by generating personalized descriptions for each user type. A natural outcome of this research is to bridge the
gap between the descriptions and permissions. Studies such as also address to bridge the gap between
the descriptions and permissions, but this time by performing as a recommender system that describes the reasons of the
usage of a permission, again by using the descriptions as a reference. Another gap in generated descriptions is resulted
from the lack of information that needs to collected about third-party libraries. These studies should be extended with
third-party library documents and their API documentation.

A similar concern also lies in the studies that aim to generate malware behaviour explanations. The current studies focus
only on malware detection without providing any reasons for the detection result. However, it would be more useful to
have an explanation about why an app is considered as malware. This would help to decrease or reverse the damage
caused by the malicious application. It would also help malware analysts by reducing their analysis time.
address this problem by automatically generating malware behaviour explanations. Recently privacy policies
have also been generated automatically to inform the user about the information that he/she provides to the app

2017] with the privacy concerns.

We expect to see more work on automatic generation of privacy policies. The enforcement by authorities such as

Google’s announcement on privacy policies [Google Play} |2019b] is expected to lead developers to create useful and
understandable privacy policies. Since privacy policies are suggested to use a simple language, such policies could be

simply generated by template-based methods [Reiter and Dale} |1997| [Mcroy et al-| 2003]. Such texts could be generated
by both using information given by developers or information obtained as a result of the code analysis. Many useful
information such as the requirement of dangerous permissions, the flow of private data could be included in policies,
hence contribute to solve the description-to fidelity and privacy problems together.

5 Privacy

One of the main threats in Android apps is the leakage of private data such as contact lists and user location. In the

literature, conventional taint analysis (Enck et al.| {2014 2014] is generally proposed in order to provide

users’ privacy. However here, new approaches based on NLP are investigated.

SUPOR [Huang et al.|/2015] complements the privacy studies in the literature by identifying sensitive user inputs. It
has three major steps: layout analysis, user input (UI) sensitiveness analysis and variable binding. In the layout analysis,

input fields of apps are listed. In the UI sensitiveness analysis, a keyword-based approach is applied to input text labels
that are closest to input fields for finding sensitive inputs. This is the only step that adapts NLP techniques. Sensitive
keyword dataset is constructed by using text in the resource files collected from 54,371 apps. First, each text line is
transferred into a parse tree by performing syntactic parsing with Stanford parser [Manning et al.| [2014], then nouns
and noun phrases are identified by level-based traversals on the parse trees. Finally, sensitive keywords are determined
manually. However, during determining the keywords, the dataset is expanded by adding the synonyms of the keywords
from WordNet [Miller] {1995}, and moreover by translating the keywords into Chinese and Korean languages by using
Google Translate. Although this lightweight keyword-based approach is promising for sensitive inputs, context-sensitive
semantic analysis could be employed for further improvements. The last step associates sensitive user inputs with
variables in the code.

UIPicker aims to identify user input privacies that are related to account credentials, user profiles,
location, and financial activities. UI screens are analyzed to identify any sensitive input. First, pre-processing is applied
on the textual data obtained from the user inputs and layout descriptions using NLP tasks such as word segmentation,
stemming, and redundant content removal. Chi-Square test is applied to cluster the user input terms that are either
privacy related or not. Then, the extracted privacy-related terms on user input and layout descriptions are used as
features in Support Vector Machine (SVM) to detect any privacy-related data. In the final step, irrelevant items detected
by the classifier in the results are further filtered out by analyzing its behaviour in its program code. The results show
that UIPicker can efficiently detect user input privacy data, although it does not consider dynamically generated user
input items.

ClueFinder [Nan et al.|/2018] applies NLP to identify sensitive data on program elements. Once a list of privacy-related
keywords is collected from the Google Privacy Policies [Google}|2019] and other privacy-related research [Emily Steel


A PREPRINT - JULY 8, 2021

2019 2016a 2017], it is extended by using word2vec [Mikolov et al.|/2013a

and Google Play apps. Then, these keywords are matched with program elements such as variables or methods inside
the code, which are the initial sensitive tokens. To further filter out the sensitive tokens, stemming, PoS tagging, and
dependency parsing are applied and thus program elements that include sensitive tokens but not related to privacy
content are filtered out. Then, all method invocations are analyzed and features such as method name, parameters, and
return type are used as features to be used in the classifier to detect any privacy data. Finally, a data flow is performed to
check whether private data is passed through unauthorized third parties. As for the evaluation, high precision scores
are obtained. BIDText also searches for sensitive keywords inside the code. However, it does
not utilize any syntactic task. The results show that ClueFinder has a higher coverage in sensitive source discovery
compared to BIDText.

Pluto |Demetriou et al.|/2016b] explores whether the app exposes any user data to advertising libraries. Such data

exposure attacks are handled in two attack channel categories: in-app and out-app. In-app attacks are dependent on the
ad library’s host app and out-app attacks are independent of the host app. In this study, only the detection of in-app
attacks which includes NLP-based techniques are reviewed. The framework flows in two steps: First, an app is run on
an emulator by simulating user inputs by using monkey [Android] |2019al, thereby extracting the runtime generated files.
Second, data points are extracted from those files and matched with their synonyms by using Wordnet [Miller] [1995].
However, a data point can be mapped to several different synonyms depending on the context. For example, the word
exercise might correspond to workout if it is a fitness app, however it might be used in an education app as well, and in
that context its snynonym would be different. In order to disambiguate a word, domain knowledge is extracted from the
file name or from the table names. If the similarity between a word and its domain knowledge is above a threshold
value, then the matching is accepted. Hence, the data points are disambiguate? |within that context. A similarity metric

derived from the LESK [Banerjee and Pedersen} |2002] algorithm is used to find the similarity between the terms based

on the Wordnet dictionary.

GUILeak [Wang et al.|/2018] aims to determine any privacy leakage from user input data and to detect whether any
leakage violates the privacy policy of a given app. The framework uses an ontology which is built manually by first
creating a phrase dictionary extracted from a set of privacy policies and then defining the semantic relationships between

those phrases. A program analysis toolkit called GATOR [Rountev and Yan}|2014] is utilized to extract user input views
from the application’s code along with a data flow analysis. Those user input views are labelled using a string analysis

technique on the arguments of the API method invocations and dialogs are inserted into their
parent activities so that dialog titles and user input labels could be identified for each parent. Policy phrases and input
fields are hierarchically mapped to the ontology concepts by using Wordnet and the cosine similarity
between the word vectors of the phrases and the input fields. Eventually, any policy violation is detected using the input
data flow and the results show that privacy policy violations through the user input data can be detected effectively by
the framework.

Invetter [Zhang et al.| mainly focuses on security-focused input validations. Not all the user input validations
involve necessarily security checks. For example, a user input could be just compared to a predefined input format to
ensure it is in the correct form. Invetter combines static analysis with machine learning methods to detect insecure
input validations. NLP is exploited to preprocess the input parameters through word segmentation, stemming, and
variable name normalization so that unstructured, ill-defined and fragmented textual data is cleaned and becomes easier
to process. Once these preprocessing steps are performed, a total number of 1132 input validations are obtained. In
order to detect the input validations that involve any sensitive input, the nearby sensitive input validations are observed
since developers normally locate similar input validations in adjacent places. Therefore, a small seed of sensitive input
validations are built by investigating whether an input validation verifies the user identity or restricts the usage of
sensitive resources in order to discover other sensitive input validations using association rule mining. The results show
that Invetter has a decent coverage in identifying the sensitive input validations.

Differently from the other related work that addresses the privacy leakage problem that occurs through the user input,
analyze the privacy policies to detect any inconsistency between the policies and the actual
actions of the app. To this end, the authors classify the privacy policies by using the TF-IDF vectors that are built by
the keywords and the bigrams of the keywords in the privacy policy statements. For example, for the location sharing
practice, the authors use keywords such as geo and gps to find all the relevant sentences in the privacy policies, and the
actions in those sentences are gathered along with their bigrams. Eventually SVM and logistic regression are used for
the classification. Those analysis results are compared to what actually an app is doing through a static analysis. Their
evaluation shows that the proposed approach is reliable and the accuracy is above the baseline.

>The task is called Word Sense Disambiguation, where a particular sense of a word is identified in a given context.

12


A PREPRINT - JULY 8, 2021

5.1 Discussion

In this section, the studies that aim to prevent any leakage of private data through the user inputs are revised under
the privacy concerns. Although the overall detection results are promising in this category of studies, there are still
limitations of the frameworks. For example, if the data is encrypted, then the privacy violations may not be detected
Siig Roark or if the user provided data is stored in a file, again the violation may not be detected
. Moreover, keyword-based approaches without trying to find the relations between the words/phrases within a
sentence may not extract relevant privacy-related keywords, which may lead to false positives. Therefore, most of the
privacy-related studies use dependency parsing to extract the privacy-related keywords |Nan et al. Huang et al.
[2014]. Those keywords are expanded by using either Wordnet 2015] or word2vec [Nan et al.
for the synonyms. It is also not possible to detect the sensitive keywords without understanding the Android
framework. Therefore, it is a good idea to combine the inferred semantics using the potentially sensitive keywords with
other information extracted from the Android framework, such as the package name.

In the future, more recent deep neural network architectures could be applied for extracting the keywords and the
relationships between them. For example, attention networks have
shown a significant improvement on almost any NLP task (e.g. machine translation) and they could be utilized for the
privacy-related problems. Those networks enable to find the important bits of information in any task. For example, in
machine translation, during the translation of a word in a target language, the attention (i.e. the contribution) will be
much higher for the equivalent word in the source language. Therefore, a similar approach also could be applied to spot
the sensitive keywords especially for the privacy problem.

A further step in the privacy-related research would be also the automation of the ontology construction, which will
save considerable amount of time.

6 Malware Detection

In recent years, NLP techniques are employed to enhance malware analysis and detection techniques in Android. Such
proposals are studied under three groups here. The first group covers proposals for assessing description-to-behaviour
fidelity in order to detect outliers in different app categories or to find suspicious apps which need further analysis
to tag them as malicious or benign. Some of these studies are also covered under description-to-behaviour fidelity
proposals above, however here, their ability on malware detection is put under investigation. Recently, text-based
features are taken into account in mobile malware detection, the second part studies how these proposals employ
NLP-based techniques in order to extract text-based features from app code and/or app metadata. In the last group,
studies that focus on extracting the profiles of benign and malicious apps by using NLP are brought together.

6.1 Description-to-behaviour Fidelity

CHABADA [Gorla et al.) is a system that checks application behaviour against application descriptions by
using static analysis and NLP techniques. Even though it is not claimed to be a malware detection system, it could
complement traditional detection techniques. CHABADA firstly defines the topics of collected apps by using the topic
modelling method LDA (Latent Dirichlet Allocation) [Blei et al.||2003]. Then, apps are clustered based on their topics
using K-means algorithm. Then, the usage of sensitive APIs for each cluster is extracted statically. Finally, the outliers
of each cluster with respect to their API usage are detected by using one-class SVM. The main aim is to find the
applications whose behaviour is not consistent with the topic clusters that it belongs to. For example, while accessing
your location is normal for a weather app, it might be abnormal for a calendar app. Besides detecting such anomalies,
CHABADA is assessed for detecting malwares. The results show that CHABADA could detect 56% of the malicious
apps, obtained from a part of Malgenome dataset [Zhou and Jiang] . A recent study takes
into account third-party libraries in order to improve CHABADA [Gorla et al.| [2014]. It follows a similar approach as
CHABADA, but removes third-party libraries from the code. Hence, it could decrease false positives by filtering out
outliers resulting from the third-party libraries. Moreover, malicious code could be pinpointed.

TAPVerifier [Yu et al.|/2017], which is mentioned above as an enhancing approach for description-to-behaviour fidelity
by using privacy policy of applications, is also explored on malware detection and compared with CHABADA
fet al. [2014]. The experiments are performed on 12 apps out of the malicious apps detected by CHABADA, since only
those applications’ privacy policies could be obtained. The experimental results show that most of the apps tagged
as malicious by CHABADA are false positives and some of these false positives could be eliminated by taking app’s
description and privacy policy into consideration. Even though, such approaches for assessing description-to-behaviour
fidelity could improve malware detection, they need further scrutiny in order to prove that.

13


A PREPRINT - JULY 8, 2021

6.2 Using Text-Based Features

Besides static and dynamic features of apps, metadata (%3) has been started to be used for malware detection
[2015]. Some recent studies 2016} 2016] use metadata of apps
in addition to other static features such as permissions, API calls. In [Ban et al.| , category information and
description of apps are given as inputs to the SVM algorithm besides permissions and API calls. Descriptions are
pre-processed and their TF-IDF representations are generated. By employing LDA on the TF-IDF representations and
employing K-means clustering on LDA, the binary representation of the clustering is produced. The classifiers are
generated by using different sets of features. When metadata features are provided, both models based on permissions
and API calls have improved. While the effect of metadata features is more influential on the permissions-based model,
it slightly affects the API calls-based model. ADROIT uses app descriptions besides permissions
and other metadata collected from the app store (user ratings, number of votes, minimum Open GL and SDK versions)
as features for discriminating malware from benign apps. In order to represent descriptions, a corpus for building a
term-document matrix is constructed. In order to do that, descriptions are pre-processed by removing special characters
and stopwords, stemming and stripping white spaces. In the results, the positive effects of metadata of apps on malware

detection are shown on the dataset collected by [Aptoide}||2019].

analyze apps based on two approaches: Semantic Pattern Transformation and statistical-based
analysis. They use metadata features such as description, price, number of downloads, information about developers.
The main idea of Semantic Pattern Transformation is to convert value-centric vectors into semantic-aware presentations.
This transformation allows to analyze semantic relations between features, to search such semantic relations and to
extract relevant features. In this transformation, some basic NLP techniques are applied in order to process descriptions
such as removing stopwords, lemmatization, and PoS tagging. In the statistical-based analysis, apps are analyzed based
on statistics of metadata such the frequency of words in the applications belonging to the same category. Both analyses
support that knowledge extracted from metadata, which could be useful for malware detection and could complement
more advanced techniques. Even though the analysis is not integrated with a malware detection system which is left as
a future work, it is proposed as an alternative method that does not require applications’ packages and execution of
applications.

Another use of app descriptions is proposed for app clone detection [Lyu et al.| 2017}, since repackaging, where the
malicious code is injected into benign apps, is quite popular among Android malware
fet al.|/2013). In the proposed approach called FUIDroid, at first descriptions are employed in order to find apps with
similar functionality. Then similar ones are further investigated for UI similarity. Here, only the first component
which includes NLP-based techniques will be explained. In that component, firstly the most used 15,000 keywords
in descriptions are extracted by using basic NLP techniques to construct a standard dictionary. Then descriptions are
represented as dynamic vectors filled with the index of description keywords in the dictionary. Since distance-based
similarity calculation such as cosine similarity is not suitable due to complex computing, a tree-based multi-keyword
approach is applied [Xia et al-|/2015]. The experimental results show that the size of suspicious cloned apps forwarded
for UI analysis is importantly reduced by using this method, hence the approach gains scalability.

For supporting such studies, a new malware dataset called RmvDroid [Wang et al.| |2019a] is recently introduced.
RmvDroid not only contains application, but also application metadata such as user rating, category, app desciption,

developer name, app installs.

A study on grayware is given in |Andow et al.\!2016]. While malware deliberately harms mobile users/devices, grayware
falls in an gray area. It is defined as apps cannot be labeled as malware, but still negatively affects users in terms of

privacy, performance and user efficiency and analyzed under 9 categories |Andow et al. . Two of them are related
to installation tactics: impostors and misrepresentators. Impostors are apps that impersonate other apps, especially
popular ones for ensuring to be installed ||Andow et al. . A recent study shows that a considerable amount

of impostors apps are malicious and among top apps in Google Play ||Rajasegaran et al.||2019]. Misrepresentators
are apps that claim to provide functionality to users that is not implemented in the app code |Andow et al.||2016].

These categories are of particular interest to this study, as they may require NLP techniques to be detected. The same
hypothesis is proposed in [|Andow et al.||2016] that text analytic techniques are needed besides program analysis for
triage such apps. Even the simple text analytic techniques are shown to be useful for decreasing the number of grayware

apps to be analyzed by humans [Andow et al.||2016]. Future work could explore more advanced techniques.

A different approach by enhancing Android malware detection with tweets is introduced in |DeLoach and Caragea
2017]. In the study, how to link apps with related tweets are explored at first. TF-IDF and Weighted Matrix Factorization

approaches are employed to represent descriptions and tweets as vectors. Then, the similarity scores between documents
are computed by using the cosine similarity. The performance of the linking approaches are evaluated on a ground truth

dataset, in which apps are obtained from AndroZoo [Alix et al.||2016] and PlayDrone [Viennot et al.|/2014], and their

related tweets collected by using the HTTP-based linking (the existence of a link to the app in the tweet). For malware

14


A PREPRINT - JULY 8, 2021

detection, in addition to traditional features 2015], tweet-based features, namely TF-IDF vector, WMF
vector, the sentiment of tweets identified by the Stanford NLP library and metadata of tweets
such as the number of followers of the corresponding tweet’s author are employed. The results show that if tweets are
successfully linked to apps, tweet-based features, especially the ones related to metadata of tweets, are beneficial for
improving malware detection.

A recent study treats HTTP flows of apps as textual documents, inspired by similarities between
application protocols and natural languages [Yun et al.|/2016]. Since HTTP/HTTPS are the major protocols used by
malware, they extract text-level features from HTTP flows in order to classify apps into benign or malware by using
SVM. Firstly, HTTP flow headers are divided into words by applying word segmentation. Here, special characters
included in HTTP headers are used for segmentation. Then, after cleaning headers from meaningless and stop words,
they are represented as n-grams. n is experimentally chosen as 1, which means different words in headers are assumed
to be independent from each other. Finally, feature vectors are constructed by representing each flow header as a one-hot
vector by only considering presence of words in the header. The experiments produce high detection rate (99.15%) with
a very low false positive rate (0.45%).

One of the earliest studies in Android security that correlates texts in UI with the code is AsDroid (Anti-Stealth Droid)
[Huang et al.|/2014], which defines stealth behaviour as the behaviour that do not match with UI. For instance, a “login”
button that leads to a phone call is considered as a stealthy behaviour. The proposed approach has two main steps: static
and UI analysis. Static analysis finds a top level function of UI (e.g. onClick() function of a button) that is associated
with the behaviour of interest. Six types of behaviours are considered in the paper: sending sms, making a phone call,
http access, install, sms notification and ui operation. In UI analysis, the intent of the behaviour is matched with UI
by using text analysis techniques. Firstly, the text that corresponds to a top level function is extracted from the static
layout construction. Then, keywords are parsed by using the Stanford Parser in order to create a set
of keywords for each intent. Here, keywords or keyword pairs that have the highest frequency and that cover all the top
level functions with the intent type of the interest are obtained. The set is enriched by adding synonyms of the keywords
by using Chinese WordNet [National Taiwan Uni.|/2019}. The final set is checked by a human analyst. Finally, for a top
level function with UI text T and the intent I, the algorithm searches T in the keyword set for I. If a match is not found,
the behaviour is labelled as malicious. AsDroid produces promising results, hence the research community has moved
in the direction of discovering useful information from UI texts for privacy as shown above. While the approach is
simple and effective, more advanced text analysis and image analysis techniques for more advanced malware are left as
future work.

6.3 Extracting Applications Profiles

An interesting approach proposes a framework called apk2vec in order to automatically build behaviour profiles of
given Android apps that could be used for many tasks from malware detection to app recommendation
[2018]. In this work, once the static analysis is performed by generating three different dependency graphs obtained

from API dependencies, permission dependencies and source-risk dependencies, those dependency graphs are used
to train the embeddings using the skipgram architecture of word2vec [2013a]. Word2vec
enforces the words co-occurring in similar contexts to have similar embeddings while training for word
embeddings. Therefore, given an input word to the one layer neural network, the output is the predicted context of this
word. Analogously, in apk2vec, the apk id is given as input to the neural network and the network is expected to predict
the API, permission and source-sink subgraphs that occur in the apk’s context. Therefore, the embeddings of the API,
permission and source-sink subgraphs tend to be closer to each other if they have the same apk class label, such as
malware.

apk2vec is shown to be useful for many security related tasks. In batch malware detection, SVM is employed to classify
the profiles of collected apps from Virus Share [VirusShare| [2019], Drebin and [Google Play] [2019a].
In online learning, apps are firstly ordered according to their release data, then the first part is used to train an online
Passive Aggressive classifier. For malware family classification, K-means algorithm is employed for clustering the
Drebin dataset into 179 families. All results of these tasks support that apk2vec is task-agnostic and
represents app semantically well. Another usage of apk2vec for security is clone detection. A recent study
employs icon and text embeddings of apps and their similarities to the embeddings of popular apps in order
to find impostor apps (counterfeit apps as given in the study). Even though the main contrubiton of the study is to
propose a new approach on combining content and style embedding from pretrained convolutional neural networks
(CNNs) in order to calculate the similarity of app icons, it is shown that the results are increased by 3%-5% (precision)
and 6%-7% (recall) by including text embeddings of app descriptions.

FeatureSmith |Zhu and Dumitras}|}2016] differs from other NLP-based malware detection systems by proposing an

approach for automatic feature engineering. It adopts scientific papers in the literature as the source of information and

15


A PREPRINT - JULY 8, 2021

Table 2: Outline of Related Studies

Problem Sub-Category Related Work
Description

DESCRIPTION-to-BEHAVIOUR

Review
{20T9|
artP Wang et al.||2019b
LSTM-based ]ATecakir et al.
Privacy Policy TAPVerifier ‘Yu ef al. |/20T7)
PPChecker :
Code [Wang et al.]|Z01 7a]
Description Des V Zhang et al.|/2015
DESCRIPTION GENERATION ON [Wu et al,}|2019)
Privacy Policy

Permission Explanation
Malware Behaviour
PRIVACY N/A

Description-Behaviour
MALWARE DETECTION

Using Text Features

Extracting App Profiles apk2vec Narayanan et al.|/20T8|
dD

FeatureSmr

mines them for extracting malware features. Even though it is a generic approach, Android malware detection is selected
as the proof-of-concept study. It extracts 195 features by mining 1068 scientific papers on the area. For the feature
extraction, at first, the Stanford dependency parser is used to extract the dependencies that correspond
to basic malware behaviours. Those dependencies are used to build an ontology where each node corresponds to the
behaviours, malware families and concrete features and the edges correspond to the relations between the entities.
Edges are also weighted by the semantic similarity between the entities, so that features could be quantified based on its
relevance to detect Android malware. It is compared with Drebin which employs 545,334 manually
engineered features. Random forest classifiers are trained with these feature sets and compared. The results show that
FeatureSmith reaches to the similar performance with Drebin, even with very small set of features. Furthermore, it
could detect some malware families (e.g. Gappusin) that Drebin cannot detect.

6.4 Discussion

Although the studies reviewed in this section show that using NLP-based techniques and text-based features can help
improve malware detection, they are at an early stage. While CHABADA and TAPVerifier
have mainly proposed for assessing the description-to-behaviour fidelity, their effects on malware detection are
also evaluated, but in a very limited way. Such evaluations, hence such studies can be further improved by using larger
datasets. From this point of view, introduction of malware datasets including metadata such as RmvDroid
[2019a}, AndroZoo++ |Allix et al.|/2016] are good initiatives for accelerating research on this domain. Furthermore,
topic-specific security on [eorla cal] Bora] Wang eral] 2077), which employ LDA-based techniques on app

descriptions for finding apps’ topic, helps characterizing malware based on topics they belong to.

In malware detection, researchers mainly use text-based features extracted from descriptions [Martin et al.||2016
2016} 2016]. Other metadata such as user reviews, privacy policies processed by NLP techniques

could be employed to enrich feature vectors. Social media could be another source that could be exploited for obtaining

16


A PREPRINT - JULY 8, 2021

text-based features [|DeLoach and Caragea}|2017]. Moreover, more advanced NLP techniques could be employed to

extract features, detect malware and grayware such as misrepresentators.

Deep learning techniques with word embeddings have shown dramatic improvements in many NLP tasks. The popular
word embedding model word2vec [Mikolov et al. has inspired many new vecs to emerge such as apk2vec
[2018], spam2vec [Maity et al.||2018]. The main idea of something2vec studies is that similar
somethings of the same type (e.g. words, spams) could be represented by vectors located close to each other in
the vector space. Similar idea could be used for the purpose of Android security from malware family detection to
repackaging detection by representing malware as vectors by using rich information of apps. apk2vec

2018] based on this idea extracts Android app profiles. In the future, such studies could be enriched by using more
information such as metadata with the aim of malware detection.

7 Related Work

In this section, traditional security mechanisms proposed for Android security are presented shortly. Two common
types of malware analysis and detection techniques are static and dynamic analysis. Static analysis analyzes the code
and the application package without running the code. On the other hand, dynamic analysis monitors the runtime
behaviours of apps. Permissions and API calls are among the most used features in static analysis |Feizollah et al.

2015]. Static analysis is not resilient to some evasion techniques such as obfuscation [Rastogi et al.|/2013}/|Sen et al.
2018], dynamic code loading [Xue et al.||2017 2018]. Hence such techniques are not very successful

at detecting new attacks or even new variants of existing attacks. There are also effective evasion strategies against
dynamic analysis. For example, a malicious app could hide its malicious behaviours when it identifies being run in a
virtual machine environment [Petsas et al.| \Vidas and Christin| [2014]. While a bare-metal analysis could be a
solution to this problem ||Mutti et al.|/2015]], such systems are generally not very efficient for analyzing a large number
of apps. Triggering malicious code part in apps is another issue for runtime analysis. Even though there are proposals
on automatically triggering malicious code in Android [Abraham et al. [2016} Li et al’ (2017),
they might not be very effective for all kinds of malware [Choudhary et al.|/2015]. In addition, dynamic analysis might
not be affordable on some devices due to their resource constraints, especially in terms of power. Therefore, security
solutions on mobile devices known as anti-malware systems mainly rely on static analysis.

As it is summarized, both techniques have advantages and disadvantages. There exists also hybrid approaches that
combine both techniques [Rasthofer et al.| 2016} {Chakraborty et al] {2017} [Aktas and Sen|/2018}. All these techniques
could be applied at both on device or on the app stores. Some markets analyze submitted apps before making them
available for download and install. Taint analysis is another effective technique for detecting data leaks in mobile

devices through constructing data flows statically or dynamically. Taintdroid |Enck et al.|/2014] and FlowDroid
2014] are among the well-accepted studies in this area. Please see a recent survey of Android malware and

analysis techniques for further information [Tam et al.|/2017].

One of the earliest work on exploring the usage of NLP for security [Atallah et al.||2000] divides the possible applications
of NLP in information assurance and security into four groups: NLG for memorizing random strings such as strong

passwords, watermarking natural language text, applying machine translation for information security (e.g. translating a
text into another language before encrypting it), and sanitizing information. However, since this publication there have
been many advancements in both information security and NLP. For example, there are recent promising approaches of
NLP in cyber security from cyber threat intelligence to anomaly detection

using sequential data such as logs [Du et al.,/2017] and social media |Chambers et al.||2018

The deployment mechanism of mobile apps has recently attracted researchers to explore the application of NLP
techniques in this research area. There are already few review studies on application store analysis for software

engineering [Martin et al.|/2016}|Genc-Nayebi and Abran||2017]. However it is believed that there is also a need to

review the literature from the security point of view. This 1s the main aim of the current study.

8 Discussion

The discussion section is covered under three subsections. Firstly, the general discussion of existing NLP-based studies
on Android security is given. Then, the strengths and weaknesses of the NLP techniques in Android security are
discussed. Finally, possible directions for future research are summarized.

17


A PREPRINT - JULY 8, 2021

8.1 NLP-based Approaches in Android Security

The studies on the use of NLP methods for Android security has been exploring for the last five years, so it is still in
its early stage. In this study, we have given a survey of research on NLP-based techniques for Android security for
the following four research problems: description-to-behaviour fidelity, description generation, privacy and malware
detection, and the proposals are discussed separately for each problem. The studies in the literature are summarized in
Table [2] In this section, a general view of the proposed studies is aimed to be represented. Moreover, how they could be
employed to complement traditional security solutions will be discussed.

While the studies mainly focus on application descriptions, other type of metadata in textual form, especially privacy
policies and user reviews, need to be the subject of further studies. The use of privacy policies is a good candidate from
the security point of view. Moreover, the enforcement on the use of privacy policy by Google is expected to make such
approaches more applicable in the near future. Furthermore, these documents are expected to be simple, hence simpler
to be processed by NLP-based techniques. Appropriate weight should also be also given to user reviews, which directly
reflect the experience of users on applications. The effects of different type of metadata on Android security should
need to be explored.

Adversarial attacks against NLP-based systems in Android is an open research area. With the increasing popularity of
deep learning methods in NLP, such methods have also become the target of attackers
. We believe that with the increase in the use of NLP techniques in Android security, new attacks against such
systems are going to emerge. Evasion and poisoning attacks are among the mostly studied attacks in other domains
(Corona et al.|/2013]. In Android security, how attackers could evade from the NLP-based solutions and how they
could poison the training of an NLP system with well-crafted data needs to be studied. For instance, the effects of fake
reviews should be analyzed and researchers should address how to select effective user reviews.

There would appear to be insufficient research on text generation. Automatic generation of descriptions or privacy
policies could help developers to generate user friendly metadata. Furthermore, if some rule-based approaches are
enforced by market stores for this problem, a generic form of metadata could be generated, which helps to process the
text. Such techniques could also be used for the explanation of mobile malware and complement works on malware
familial classification based on program analysis [Mirzaei et al.|/2019]. Such approaches could
give an idea about the detected malicious application to malware analysts, hence helps to reduce their time on malware
analysis. Furthermore, if the behaviour of a detected malware is known, specific steps can be taken to decrease or
reverse the damage caused by the malware.

We believe that NLP-based techniques could complement the traditional approaches in the literature well. If we find
inconsistencies between permissions and user metadata, this would be a strong indication of a malicious application.
Then, more resource-intensive analysis techniques could be applied on such apps. Moreover, traditional code analysis
techniques could be enhanced with semantic analysis by considering some part of the code as text (e.g. method names,
API calls).

8.2 Strengths and Weaknesses of the NLP Techniques in Android Security

As reviewed in this article, a wide range of NLP techniques have been used for the problems relevant to Android
security. NLP has evolved substantially in the last decade by having most of the statistical-based methods extinct and
transforming the traditional methods into deep learning-based models. Other research fields like Android security have
their share during this evolution. While early work on Android security was using statistical-based models such as
tf-idf to obtain the vectorial representations of words to define their semantics, the recent work is using more neural

representation models such as word2vec ||Mikolov et al.||2013a]. However, frequency based models such as tf-idf are
still being widely used by the Android security field.

Learning semantics is one of the key problems under Android security for almost all of the problems such as description-
to-permission fidelity, privacy policy, or description generation. Tf-idf is a simple scoring scheme and it only defines
how important a word is in a document. It gives some clues about the semantics of a word, but it is not as powerful as the
neural representation models. On the other hand, neural representation models have the ability to capture all semantic
and also syntactic features of a word and can effectively define everything in a low-dimensional vector, whereas tf-idf is
a linear vector where the size of the dimension is equal to the vocabulary size in the corpus. Therefore, it brings also
performance issues, which is quite important in tools developed for Android security. Feature extraction and dimension
reduction need to be performed to alleviate the performance problem in such cases. From the adversarial attacker point
of view, the methods which are directly based on the frequencies or the occurrences of words have the potential to be
deceived, whereas neural models can build a compact representation of any text and it could be more stable compared
to frequency-based models. However, from the other hand, neural models are highly dependent on the data that they are

18


A PREPRINT - JULY 8, 2021

trained on. Rather than a general corpus, it would be more robust to train such models on domain specific corpora on
security related texts.

WordNet has also been widely used by researchers on Android security in order to extract semantic
information from textual data and it is still used in security. The major limitation of WordNet is that it is restricted with
its hierarchical representation and since it is hand-crafted, it is built for general purposes and it is not domain-adapted.
However, neural models such as word2vec can be easily trained on a domain specific corpus
and more specific neural word embeddings could be obtained. If any hierarchy (e.g. synonym, hypernym, or hyponym)
is required along with the meaning, then ontology-based corpora such as WordNet could be more beneficial, since
it is harder to obtain this kind of hierarchies in neural word embeddings. However, if solely semantic similarity or
relatedness is required, then neural word embeddings are more effective compared to ontology-based models.

Most of the security studies apply preprocessing on the textual data to reduce the sparsity in data. For example, in
almost any task, the stopwords are removed since they do not contribute much on the meaning. However, this might
have a side effect by substantially changing the overall representation of the text. For example, the meaning of the
description statement, “Contact your group to the new boss” is different than the stopword-filtered statement “Contact
group new boss”.

In addition to the requirements under semantics, it is essential to discuss on the syntactic level as well. In the syntax
level, studies usually perform PoS tagging and dependency parsing. Most of the studies usually adopts these tasks from
external sources such as Stanford parser [Klein and Manning] |2003]. Those external sources are quite successful for
especially English language, and it can accurately find the relations and dependencies between the phrases in a given
sentence. Since, provided textual data is quite formal in Android security, the common noise problem in NLP is not an
issue in the field. We have not come across any study that uses chunking but it would be also helpful to perform verb
phrase or noun phrase chunking to find the relevant actions or objects in a sentence, when specific actions or objects are
required to be found in a task, which could be another potential syntactic processing to be applied on the textual data
provided by Android security.

Table 3: Comparison of the NLP methods used in Android security

Models Advantages Disadvantages Related Work
Rule-based Good performance Requires too much effort PPChecker iu chal 201
to define the rules, DescribeMe =
low coverage
Statistical Do not require Fragile to adversarial
large amount of data attacks, comparably
lower accuracies
Corpus-based More robust in Requires an annotated
semantic meaning dictionary or corpus
extraction (such as WordNet

or another ontology)

Neural Easier to implement Prone to fail for
High accuracies the noisy data, requires
large amount of data apk2vec

A general overview of the NLP methods that are used in Android security is presented in Table [3] We categorize
the methods in four classes: rule-based, statistical, corpus-based, and neural models. Every method has its own
advantages and disadvantages. For example, corpus-based models that use structured (e.g. WordNet) or unstructured
(e.g. dictionaries) corpora are quite robust in estimating semantic similarity; however, it is hard to find such available

19


A PREPRINT - JULY 8, 2021

sources in many languages apart from English. The table shows that most of the studies in Android security use
either statistical models such as tf-idf vectors, machine learning classifiers etc. Another majority of the studies utilize
annotated dictionaries such as WordNet [Miller|/1995}, or other manually built ontologies. The table shows that neural
models are a new era for Android security, and only some of the recent work makes use of neural networks for security
purposes. It is worth to note that in some studies, more than one of these categories might be utilized. Here, we
categorize that study based on the dominant method.

8.3 Future Directions of the NLP Techniques in Android Security

Semantic parsing has been a new emerging task in NLP in the last decade [Banarescu et al.||2013||Abend and Rappoport

2013}|Hershcovich et al.||2019], which aims to learn the underlying semantic representations of text by finding the
relations between linguistic utterances as in syntactic parsing, but this time learning the semantics. This could be

a potential future direction in Android security as well, since most of the security-related problems require parsing
the textual data also from the semantic perspective, such as finding the permissions in a description, finding the
sensitive input entries data under privacy, or detecting the conditions in privacy policies which all refer to actions in a
security-related scenario.

The contextual word representations are the new state-of-art among the representation learning techniques |Mikolov|
ea gt oT ere eT), ET esa no Pea
Roberta [Liu et al.) are only few examples in this new trend. They have shown superior performance in many
NLP tasks, such as machine translation [Clinchant et al.| , question answering (Albert et al} 2019}, dependency
parsing etc. We believe that the usage of deep contextualized word embeddings will also help in
the tasks under Android security. For example, in the description-to-permission fidelity problem it is important to
extract the correct meaning of the word contact, which might be related to READ_CONTACT permission or not (e.g. in
sentence “Please contact us on this number.”), which can be only detected using the context of the word. In fact, it
is worth to mention that BERT [Devlin et al. has been recently used to identify opt-outs in privacy policies on
websites ee 03 although this study is not in the scope of the Android security. On the other
hand, such neural models come with their own vulnerabilities to adversarial attacks. Adversarial examples on especially

neural NLP models have been investigated in the last few years [Ebrahimi et al.|2018 2018
2019).

Last but not least, attention networks also could be incorporated in the security-related tasks. Those attention mechanisms

2014 2017] have been proven to be very powerful in almost any kind of NLP problem

(e.g. machine translation, question answering, text summarization etc.) by finding the important bits of the textual data
when specialized in a given task. They could be also used in security-related tasks |Alecakir et al.|/2021].

All of these methods and various tasks actually pursue a comprehension goal, which introduces the concept of Natural
Language Understanding (NLP), rather than Natural Language Processing (NLP). Here, the aim is to gain the computers
more like a human-level comprehension, rather than gaining just processing capabilities. We believe that Android
security will also earn its share with the advancements in NLU, by comprehending the descriptions, privacy policies,
and other relevant security data much better with those new techniques.

9 Conclusion

The availability of useful textual data in Android markets encourages researchers to associate security behaviour of
applications with such data using NLP-based techniques. This study reviews these NLP-based proposals in Android
security and shows that such techniques could be useful and complementary to traditional security solutions. The
proposals are analyzed in four categories (description-to-behaviour fidelity, description generation, privacy and malware
detection) and summarized in Table[2| These studies are in their early stage and could be evaded by attackers by using
more complex strategies. Therefore, these proposals need to be improved by using more advanced NLP techniques
in the future, and even will need to evolve towards natural language understanding. Although currently, semantics
is incorporated in Android security restrictedly by applying certain tasks from NLP, the new emerging tasks such as
semantic parsing in NLP and more advanced deep learning methods will help improving the current success of the
frameworks in Android security. Therefore, we believe that we will see more combination of NLP-based techniques
with conventinal methods for Android security in the near future.

20


A PREPRINT - JULY 8, 2021

Acknowledgements

This study is supported by the Scientific and Technological Research Council of Turkey (TUBITAK-118E141). The
authors would like to thank TUBITAK for its support.

References

Omri Abend and Ari Rappoport. Universal conceptual cognitive annotation (UCCA). In Proceedings of the 51st
Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 228-238, Sofia,

Bulgaria, August 2013. Association for Computational Linguistics. URL|https: //www.aclweb.org/anthology/
P13-1023

Adrien Abraham, Radoniaina Andriatsimandefitra, Adrien Brunelat, J-F Lalande, and V Viet Triem Tong. Grodddroid:
a gorilla for triggering malicious behaviors. In 2015 10th international conference on malicious and unwanted
software (MALWARE), pages 119-127. IEEE, 2015.

Kursat Aktas and Sevil Sen. Updroid: Updated android malware and its familial classification. In Nordic Conference
on Secure IT Systems, pages 352-368. Springer, 2018.

Chris Alberti, Kenton Lee, and Michael Collins. A bert baseline for the natural questions. ArXiv, abs/1901.08634, 2019.

Huseyin Alecakir, Muhammet Kabukcu, Burcu Can, and Sevil Sen. Discovering inconsistencies between requested
permissions and application metadata by using deep learning. In 2020 International Conference on Information
Security and Cryptology (ISCTURKEY), pages 56-56. IEEE, 2020.

Huseyin Alecakir, Burcu Can, and Sevil Sen. Attention: there is an inconsistency between android permissions and
application metadata! International Journal of Information Security, pages 1-19, 2021.

Kevin Allix, Tegawendé F Bissyandé, Jacques Klein, and Yves Le Traon. Androzoo: Collecting millions of android
apps for the research community. In 2016 IEEE/ACM 13th Working Conference on Mining Software Repositories
(MSR), pages 468-471. IEEE, 2016.

Benjamin Andow, Adwait Nadkarni, Blake Bassett, William Enck, and Tao Xie. A study of grayware on google play.
In 2016 IEEE Security and Privacy Workshops (SPW), pages 224—233. IEEE, 2016.

Android. Ui/application exerciser monkey, 2019a. (Visited November 2019) [Online]. Available:
https://developer.android.com/studio/test/monkey.html.

Android. List of android permissions, 2019b. (Visited October 2019) [Online]. Available:
https://developer.android.com/reference/android/Manifest.permission.html.
Android. Android permissions overview, 2020. (Visited June 2020) [Online]. Available:

https://developer.android.com/guide/topics/permissions/overview.

Annie I Anton, Julia Brande Earp, Qingfeng He, William Stufflebeam, Davide Bolchini, and Carlos Jensen. Financial
privacy policies and the need for standardization. IEEE Security & privacy, 2(2):36-45, 2004.

Aptoide. Aptoide, 2019. (Visited September 2019) [Online]. Available: https://www.aptoide.com/.

Daniel Arp, Michael Spreitzenbarth, Malte Hubner, Hugo Gascon, Konrad Rieck, and CERT Siemens. Drebin: Effective
and explainable detection of android malware in your pocket. In Ndss, volume 14, pages 23-26, 2014.

Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bartel, Jacques Klein, Yves Le Traon, Damien
Octeau, and Patrick McDaniel. Flowdroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint
analysis for android apps. In Acm Sigplan Notices, volume 49, pages 259-269. ACM, 2014.

Mikhail J Atallah, Craig J McDonough, Victor Raskin, and Sergei Nirenburg. Natural language processing for
information assurance and security: an overview and implementations. 2000.

Kathy Wain Yee Au, Yi Fan Zhou, Zhen Huang, and David Lie. Pscout: analyzing the android permission specification.
In Proceedings of the 2012 ACM conference on Computer and communications security, pages 217-228. ACM,
2012.

Ahmet I Aysan, Fatih Sakiz, and Sevil Sen. Analysis of dynamic code updating in android with security perspective.
IET Information Security, 13(3):269-277, 2018.

Tao Ban, Takeshi Takahashi, Shanging Guo, Daisuke Inoue, and Koji Nakao. Integration of multi-modal features for
android malware detection using linear svm. In 2016 11th Asia Joint Conference on Information Security (AsiaJCIS),
pages 141-146. IEEE, 2016.

21


A PREPRINT - JULY 8, 2021

Laura Banarescu, Claire Bonial, Shu Cai, Madalina Georgescu, Kira Griffitt, Ulf Hermjakob, Kevin Knight, Philipp
Koehn, Martha Palmer, and Nathan Schneider. Abstract meaning representation for sembanking. In Proceedings of
the 7th Linguistic Annotation Workshop and Interoperability with Discourse, pages 178-186, Sofia, Bulgaria, August

2013. Association for Computational Linguistics. URL https: //www.aclweb.org/anthology/W13-2322

Satanjeev Banerjee and Ted Pedersen. An adapted lesk algorithm for word sense disambiguation using wordnet.
In Alexander Gelbukh, editor, Computational Linguistics and Intelligent Text Processing, pages 136-145, Berlin,
Heidelberg, 2002. Springer Berlin Heidelberg. ISBN 978-3-540-457 15-2.

Srinivas Bangalore and Owen Rambow. Corpus-based lexical choice in natural language generation. In Proceedings of
the 38th Annual Meeting of the Association for Computational Linguistics, pages 464-471, Hong Kong, October

2000. Association for Computational Linguistics. doi: 10.3115/1075218.1075277. URL
org/anthology/P00- 1059

Vinayshekhar Bannihatti Kumar, Roger Iyengar, Namita Nisal, Yuanyuan Feng, Hana Habib, Peter Story, Sushain
Cherivirala, Margaret Hagan, Lorrie Cranor, Shomir Wilson, Florian Schaub, and Norman Sadeh. Finding a choice
in a haystack: Automatic extraction of opt-out statements from privacy policy text. In Proceedings of The Web
Conference 2020, WWW °20, page 1943-1954, New York, NY, USA, 2020. Association for Computing Machinery.
ISBN 9781450370233. doi: 10.1145/3366423.3380262. URL|https://doi.org/10.1145/3366423 . 3380262

David M Blei, Andrew Y Ng, and Michael I Jordan. Latent dirichlet allocation. Journal of machine Learning research,
3(Jan):993-1022, 2003.

Piotr Bojanowski, Edouard Grave, Armand Joulin, and Tomas Mikolov. Enriching word vectors with subword
information. Transactions of the Association for Computational Linguistics, 5:135—146, 2017. URL https:
//wi0w.aclweb. org/anthology/Q17-1010

T. D. Breaux and A. Rao. Formal analysis of privacy requirements specifications for multi-tier applications. In 20/3
21st IEEE International Requirements Engineering Conference (RE), pages 14—23, July 2013.

Travis D. Breaux, Hanan Hibshi, and Ashwini Rao. Eddy, a formal language for specifying and analyzing data flow
specifications for conflicting privacy requirements. Requir. Eng., 19(3):281-307, September 2014. ISSN 0947-3602.

doi: 10.1007/s00766-013-0190-7. URL\http: //dx.doi.org/10.1007/s00766-013-0190-7

Aoife Cahill, Martin Forst, and Christian Rohrer. Stochastic realisation ranking for a free word order language.
In Proceedings of the Eleventh European Workshop on Natural Language Generation (ENLG 07), pages 17-24,

Saarbriicken, Germany, June 2007. DFKI GmbH. URL https ://www.aclweb. org/anthology/WO07- 2303

Jr. Richard J. Caira and Taylor Ey. Heads up, app developers: Google is getting serious about privacy and data security
in apps, 2019. (Visited October 2019) [Online]. https://www.natlawreview.com/article/heads-app-developers-google-
getting-serious-about-privacy-and-data-security-apps.

Kris Cao and Stephen Clark. Latent variable dialogue models and their diversity. In Proceedings of the 15th Conference
of the European Chapter of the Association for Computational Linguistics: Volume 2, Short Papers, pages 182-

187, Valencia, Spain, April 2017. Association for Computational Linguistics. URL https: //www.aclweb.org/
anthology/E17-2029

Daniel Cer, Marie-Catherine de Marneffe, Dan Jurafsky, and Chris Manning. Parsing to Stanford dependencies:
Trade-offs between speed and accuracy. In Proceedings of the Seventh International Conference on Language
Resources and Evaluation (LREC’10), Valletta, Malta, May 2010a. European Language Resources Association
(ELRA).

Daniel M Cer, Marie-Catherine De Marneffe, Daniel Jurafsky, and Christopher D Manning. Parsing to stanford
dependencies: Trade-offs between speed and accuracy. In LREC. Floriana, Malta, 2010b.

Tanmoy Chakraborty, Fabio Pierazzi, and VS Subrahmanian. Ec2: ensemble clustering and classification for predicting
android malware families. [EEE Transactions on Dependable and Secure Computing, 2017.

Nathanael Chambers, Ben Fry, and James McMasters. Detecting denial-of-service attacks from social media text:
Applying nlp to computer security. In Proceedings of the 2018 Conference of the North American Chapter of
the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long Papers), pages
1626-1635, 2018.

Wanxiang Che, Yijia Liu, Yuxuan Wang, Bo Zheng, and Ting Liu. Towards better ud parsing: Deep contextualized word
embeddings, ensemble, and treebank concatenation. In Proceedings of the CoNLL 2018 Shared Task: Multilingual
Parsing from Raw Text to Universal Dependencies, pages 55-64. Association for Computational Linguistics, 2018.

URL http: //aclweb.org/anthology/K18- 2005

Wei Chen, David Aspinall, Andrew D Gordon, Charles Sutton, and Igor Muttik. A text-mining approach to explain
unwanted behaviours. In Proceedings of the 9th European Workshop on System Security, page 4. ACM, 2016.

22


A PREPRINT - JULY 8, 2021

Xueqi Cheng, Xiaohui Yan, Yanyan Lan, and Jiafeng Guo. Btm: Topic modeling over short texts. [EEE Transactions
on Knowledge and Data Engineering, 26(12):2928—2941, 2014.

Kyunghyun Cho, Bart van Merriénboer, Caglar Gulcehre, Fethi Bougares, Holger Schwenk, and Y. Bengio. Learning
phrase representations using rnn encoder-decoder for statistical machine translation. 06 2014. doi: 10.3115/v1/
D14-1179.

Shauvik Roy Choudhary, Alessandra Gorla, and Alessandro Orso. Automated test input generation for android: Are we
there yet?(e). In 2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE), pages
429-440. IEEE, 2015.

Aske Simon Christensen, Anders Mgller, and Michael I. Schwartzbach. Precise analysis of string expressions. In
Proceedings of the 10th International Conference on Static Analysis, SAS’03, pages 1-18, Berlin, Heidelberg, 2003.

Springer-Verlag. ISBN 3-540-40325-6. URL http: //dl.acm.org/citation.cfm?id=1760267 .1760269

Cisco. 10th annual cisco visual networking index (vni) mobile forecast projects 70 percent of global population
will be mobile users, 2019. (Visited August 2019) [Online]. Available: https://newsroom.cisco.com/press-release-
content?articleld=1741352.

Stephane Clinchant, Kweon Woo Jung, and Vassilina Nikoulina. On the use of BERT for neural machine translation. In
Proceedings of the 3rd Workshop on Neural Generation and Translation, pages 108-117, Hong Kong, November

2019. Association for Computational Linguistics. doi: 10.18653/v1/D19-5611. URL https: //www.aclweb.org/

Igino Corona, Giorgio Giacinto, and Fabio Roli. Adversarial attacks against intrusion detection systems: Taxonomy,
solutions and open issues. Information Sciences, 239:201—225, 2013.

Jordan DeLoach and Doina Caragea. Twitter-enhanced android malware detection. In 2017 IEEE International
Conference on Big Data (Big Data), pages 4648-4657. IEEE, 2017.

Soteris Demetriou, Whitney Merrill, Wei Yang, Aston Zhang, and Carl Gunter. Free for all! assessing user data
exposure to advertising libraries on android. 02 2016a. doi: 10.14722/ndss.2016.23082.

Soteris Demetriou, Whitney Merrill, Wei Yang, Aston Zhang, and Carl A Gunter. Free for all! assessing user data
exposure to advertising libraries on android. In NDSS, 201 6b.

Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. Bert: Pre-training of deep bidirectional
transformers for language understanding. In NAACL-HLT, 2019.

Min Du, Feifei Li, Guineng Zheng, and Vivek Srikumar. Deeplog: Anomaly detection and diagnosis from system logs
through deep learning. In Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications
Security, pages 1285-1298. ACM, 2017.

Javid Ebrahimi, Anyi Rao, Daniel Lowd, and Dejing Dou. HotFlip: White-box adversarial examples for text clas-
sification. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume
2: Short Papers), pages 31-36, Melbourne, Australia, July 2018. Association for Computational Linguistics. doi:
10.18653/v1/P18-2006. URL https: //www.aclweb.org/anthology/P18- 2006

Emily Cadman Emily Steel, Callum Locke and Ben Freese. How much is your personal data worth?
//ig.f£t.com/how-much- is-your-personal-data-worth/, 2019. Online; accessed 29 November 2019.

William Enck, Peter Gilbert, Seungyeop Han, Vasant Tendulkar, Byung-Gon Chun, Landon P Cox, Jaeyeon Jung,

Patrick McDaniel, and Anmol N Sheth. Taintdroid: an information-flow tracking system for realtime privacy
monitoring on smartphones. ACM Transactions on Computer Systems (TOCS), 32(2):5, 2014.

Ali Feizollah, Nor Badrul Anuar, Rosli Salleh, and Ainuddin Wahid Abdul Wahab. A review on feature selection in
mobile malware detection. Digital investigation, 13:22—37, 2015.

Adrienne Porter Felt, Elizabeth Ha, Serge Egelman, Ariel Haney, Erika Chin, and David Wagner. Android permissions:
User attention, comprehension, and behavior. In Proceedings of the Eighth Symposium on Usable Privacy and
Security, SOUPS ’ 12, pages 3:1—3:14, New York, NY, USA, 2012. ACM. ISBN 978-1-4503-1532-6. doi: 10.1145/
2335356.2335360. URL http: //doi acm. org/10. 1145/2335356. 2335360

Y. Feng, L. Chen, A. Zheng, C. Gao, and Z. Zheng. Ac-net: Assessing the consistency of description and permission in
android apps. IEEE Access, 7:57829-57842, 2019. ISSN 2169-3536. doi: 10.1109/ACCESS.2019.2912210.

Evgeniy Gabrilovich and Shaul Markovitch. Computing semantic relatedness using wikipedia-based explicit semantic
analysis. In Proceedings of the 20th International Joint Conference on Artifical Intelligence, IJCAT’ 07, pages 1606-

1611, San Francisco, CA, USA, 2007. Morgan Kaufmann Publishers Inc. URL http://dl.acm. org/citation
cfm?id=1625275. 1625535

23


A PREPRINT - JULY 8, 2021

Necmiye Genc-Nayebi and Alain Abran. A systematic literature review: Opinion mining studies from mobile app store
user reviews. Journal of Systems and Software, 125:207-219, 2017.

Max Glockner, Vered Shwartz, and Yoav Goldberg. Breaking NLI systems with sentences that require simple lexical
inferences. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 2:
Short Papers), pages 650-655, Melbourne, Australia, July 2018. Association for Computational Linguistics. doi:

10.18653/v1/P18-2103. URL https: //www.aclweb.org/anthology/P18-2103

Google. Google privacy policy, 2019. (Visited November 2019) [Online]. Available:
https://www.google.com/policies/privacy/.

Google Google Play. Google play, 2019a. (Visited September 2019) [Online]. Available: https://play.google.com/.

Google Google Play. Privacy, security and deception, 2019b. (Visited October 2019) [Online].
https://play.google.com/intl/en-US/about/privacy-security-deception/.

Alessandra Gorla, Ilaria Tavecchia, Florian Gross, and Andreas Zeller. Checking app behavior against app descriptions.
In Proceedings of the 36th International Conference on Software Engineering, ICSE 2014, pages 1025-1035,
New York, NY, USA, 2014. ACM. ISBN 978-1-4503-2756-5. doi: 10.1145/2568225.2568276. URL http:
//doi.acm.org/10.1145/2568225 . 2568276

Daniel Hershcovich, Zohar Aizenbud, Leshem Choshen, Elior Sulem, Ari Rappoport, and Omri Abend. SemEval-2019
task 1: Cross-lingual semantic parsing with UCCA. In Proceedings of the 13th International Workshop on Semantic
Evaluation, pages 1-10, Minneapolis, Minnesota, USA, June 2019. Association for Computational Linguistics. doi:

10.18653/v1/S19-2001. URL https: //www.aclweb.org/anthology/S19-2001
Sepp Hochreiter and Jiirgen Schmidhuber. Long short-term memory. Neural Comput., 9(8):1735—1780, November

1997. ISSN 0899-7667. doi: 10.1162/neco.1997.9.8.1735. URL http: //dx.doi.org/10.1162/neco.1997.9
8.1735

Heqing Huang, Sencun Zhu, Peng Liu, and Dinghao Wu. A framework for evaluating mobile app repackaging detection
algorithms. In International Conference on Trust and Trustworthy Computing, pages 169-186. Springer, 2013.

Jianjun Huang, Xiangyu Zhang, Lin Tan, Peng Wang, and Bin Liang. Asdroid: Detecting stealthy behaviors in
android applications by user interface and program behavior contradiction. In Proceedings of the 36th International
Conference on Software Engineering, pages 1036-1046. ACM, 2014.

Jianjun Huang, Zhichun Li, Xusheng Xiao, Zhenyu Wu, Kangjie Lu, Xiangyu Zhang, and Guofei Jiang. {SUPOR}:
Precise and scalable sensitive user input detection for android apps. In 24th {USENIX} Security Symposium
({USENIX} Security 15), pages 977-992, 2015.

Jianjun Huang, Xiangyu Zhang, and Lin Tan. Detecting sensitive data disclosure via bi-directional text correlation
analysis. In Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software
Engineering, pages 169-180. ACM, 2016.

O John, Laura Naumann, and C Soto. Paradigm shift to the integrative big five trait taxonomy: History, measurement,
and conceptual issues, pages 114-158. 01 2008.

Dan Klein and Christopher D. Manning. Accurate unlexicalized parsing. In Proceedings of the 41st Annual Meeting
on Association for Computational Linguistics - Volume 1, ACL ’03, pages 423-430, Stroudsburg, PA, USA, 2003.
Association for Computational Linguistics. doi: 10.3115/1075096.1075150. URL

Deguang Kong, Lei Cen, and Hongxia Jin. Autoreb: Automatically understanding the review-to-behavior fidelity in
android applications. In Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications
Security, pages 530-541. ACM, 2015.

Irene Langkilde. Forest-based statistical sentence generation. In /st Meeting of the North American Chapter of the

Association for Computational Linguistics, 2000. URL|https://www.aclweb.org/anthology/A00- 2023

Yuanchun Li, Ziyue Yang, Yao Guo, and Xiangqun Chen. Droidbot: a lightweight ui-guided test input generator for
android. In 2017 IEEE/ACM 39th International Conference on Software Engineering Companion (ICSE-C), pages
23-26. IEEE, 2017.

Xiaojing Liao, Kan Yuan, XiaoFeng Wang, Zhou Li, Luyi Xing, and Raheem Beyah. Acing the ioc game: Toward
automatic discovery and analysis of open-source cyber threat intelligence. In Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security, pages 755-766. ACM, 2016.

Xueqing Liu, Yue Leng, Wei Yang, Chengxiang Zhai, and Tao Xie. Mining android app descriptions for permission
requirements recommendation. In 2018 IEEE 26th International Requirements Engineering Conference (RE), pages
147-158. IEEE, 2018.

24


A PREPRINT - JULY 8, 2021

Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Dangi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer,
and Veselin Stoyanov. Roberta: A robustly optimized bert pretraining approach. ArXiv, abs/1907.11692, 2019.

Fang Lyu, Yaping Lin, and Junfeng Yang. An efficient and packing-resilient two-phase android cloned application
detection approach. Mobile Information Systems, 2017, 2017.

Suman Kalyan Maity, Santosh KC, and Arjun Mukherjee. Spam2vec: Learning biased embeddings for spam detection
in twitter. In Companion Proceedings of the The Web Conference 2018, pages 63-64. International World Wide Web
Conferences Steering Committee, 2018.

William Mann and Sandra Thompson. Rethorical structure theory: Toward a functional theory of text organization.
Text, 8:243—281, 01 1988. doi: 10.1515/text.1.1988.8.3.243.

Christopher Manning, Mihai Surdeanu, John Bauer, Jenny Finkel, Steven Bethard, and David McClosky. The
stanford corenlp natural language processing toolkit. In Proceedings of 52nd annual meeting of the association for
computational linguistics: system demonstrations, pages 55-60, 2014.

Alejandro Martin, Alejandro Calleja, Héctor D Menéndez, Juan Tapiador, and David Camacho. Adroit: Android
malware detection using meta-information. In 2016 IEEE Symposium Series on Computational Intelligence (SSC),
pages 1-8. IEEE, 2016.

William Martin, Federica Sarro, Yue Jia, Yuanyuan Zhang, and Mark Harman. A survey of app store analysis for
software engineering. [EEE transactions on software engineering, 43(9):817-847, 2016.

McAfee. Mcafee mobile threat report, 2019. (Visited August 2019) [Online]. Available:
https://www.mcafee.com/enterprise/en-us/assets/reports/rp-mobile-threat-report-2019.pdf.

Susan W. Mcroy, Songsak Channarukul, and Syed S. Ali. An augmented template-based approach to text realization.
Nat. Lang. Eng., 9(4):381-420, December 2003. ISSN 1351-3249. doi: 10.1017/S1351324903003188. URL

https://doi.org/10.1017/S1351324903003188

Rada Mihalcea and Paul Tarau. TextRank: Bringing order into text. In Proceedings of the 2004 Conference on
Empirical Methods in Natural Language Processing, pages 404-411, Barcelona, Spain, July 2004. Association for

Computational Linguistics. URL https: //www.aclweb.org/anthology/W04- 3252

Tomas Mikolov, G.s Corrado, Kai Chen, and Jeffrey Dean. Efficient estimation of word representations in vector space.
pages 1-12, 01 2013a.

Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg Corrado, and Jeffrey Dean. Distributed representations of words and
phrases and their compositionality. In Proceedings of the 26th International Conference on Neural Information
Processing Systems - Volume 2, NIPS’13, pages 3111-3119, USA, 2013b. Curran Associates Inc. URL ‘http:
//dl.acm.org/citation. cfm?id=2999792.2999959

George A. Miller. Wordnet: A lexical database for english. Commun. ACM, 38(11):39-41, November 1995. ISSN
0001-0782. doi: 10.1145/219717.219748. URL http: //doi.acm. org/10.1145/219717 . 219748

Omid Mirzaei, Guillermo Suarez-Tangil, Jose M de Fuentes, Juan Tapiador, and Gianluca Stringhini. Andrensemble:
Leveraging api ensembles to characterize android malware families. In Proceedings of the 2019 ACM Asia Conference
on Computer and Communications Security, pages 307-314, 2019.

Simone Mutti, Yanick Fratantonio, Antonio Bianchi, Luca Invernizzi, Jacopo Corbetta, Dhilung Kirat, Christopher
Kruegel, and Giovanni Vigna. Baredroid: Large-scale analysis of android apps on real devices. In Proceedings of the
31st Annual Computer Security Applications Conference, pages 71-80. ACM, 2015.

Yuhong Nan, Zhemin Yang, Min Yang, Shunfan Zhou, Yuan Zhang, Guofei Gu, Xiaofeng Wang, and Limin Sun.
Identifying user-input privacy in mobile applications at a large scale. IEEE Transactions on Information Forensics
and Security, 12(3):647-661, 2017.

Yuhong Nan, Zhemin Yang, Xiaofeng Wang, Yuan Zhang, Donglai Zhu, and Min Yang. Finding clues for your secrets:
Semantics-driven, learning-based privacy discovery in mobile apps. In NDSS, 2018.

Annamalai Narayanan, Charlie Soh, Lihui Chen, Yang Liu, and Lipo Wang. apk2vec: Semi-supervised multi-view
representation learning for profiling android applications. In 20/8 IEEE International Conference on Data Mining
(ICDM), pages 357-366. IEEE, 2018.

University National Taiwan Uni. Chinese wordnet, 2019. (Visited November 2019) [Online]. Available:
http://ope.linguistics.ntu.edu.tw/cwn/.

D. C. Nguyen, E. Derr, M. Backes, and S. Bugiel. Short text, large effect: Measuring the impact of user reviews on
android app security & privacy. 2019.

NLTK. Natural language toolkit, 2019. (Visited October 2019) [Online]. Available: https://www.nltk.org/.

25


A PREPRINT - JULY 8, 2021

Rahul Pandita, Xusheng Xiao, Wei Yang, William Enck, and Tao Xie. Whyper: Towards automating risk assessment of
mobile applications. In Proceedings of the 22Nd USENIX Conference on Security, SEC’ 13, pages 527-542, Berkeley,
CA, USA, 2013. USENIX Association. ISBN 978-1-931971-03-4. URL

Jeffrey Pennington, Richard Socher, and Christopher Manning. Glove: Global vectors for word representation. In
Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages
1532-1543, Doha, Qatar, October 2014. Association for Computational Linguistics. doi: 10.3115/v1/D14-1162.

URL https: //www.aclweb.org/anthology/D14- 1162

Matthew Peters, Mark Neumann, Mohit Iyyer, Matt Gardner, Christopher Clark, Kenton Lee, and Luke Zettlemoyer.
Deep contextualized word representations. 02 2018.

Thanasis Petsas, Giannis Voyatzis, Elias Athanasopoulos, Michalis Polychronakis, and Sotiris Ioannidis. Rage against
the virtual machine: hindering dynamic analysis of android malware. In Proceedings of the Seventh European
Workshop on System Security, page 5. ACM, 2014.

PrivacyGrade. Privacygrade: Grading the privacy of smartphone app, 2019. (Visited October 2019) [Online].
http://privacy grade.org/home.

Danish Pruthi, Bhuwan Dhingra, and Zachary C Lipton. Combating adversarial misspellings with robust word
recognition. July 2019.

Qiao Qian, Minlie Huang, and Xiaoyan Zhu. Assigning personality/identity to a chatting machine for coherent
conversation generation. 06 2017.

Zhengyang Qu, Vaibhav Rastogi, Xinyi Zhang, Yan Chen, Tiantian Zhu, and Zhong Chen. Autocog: Measuring the
description-to-permission fidelity in android applications. In Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security, CCS ’14, pages 1354-1365, New York, NY, USA, 2014. ACM. ISBN

978-1-4503-2957-6. doi: 10.1145/2660267.2660287. URL http: //doi.acm. org/10.1145/2660267 . 2660287

Jathushan Rajasegaran, Naveen Karunanayake, Ashanie Gunathillake, Suranga Seneviratne, and Guillaume Jourjon. A
multi-modal neural embeddings approach for detecting mobile counterfeit apps. In The World Wide Web Conference,
pages 3165-3171. ACM, 2019.

Siegfried Rasthofer, Steven Arzt, Marc Miltenberger, and Eric Bodden. Harvesting runtime values in android applications
that feature anti-analysis techniques. In NDSS, 2016.

Vaibhav Rastogi, Yan Chen, and Xuxian Jiang. Droidchameleon: evaluating android anti-malware against transformation
attacks. In Proceedings of the 8th ACM SIGSAC symposium on Information, computer and communications security,
pages 329-334. ACM, 2013.

Ehud Reiter and Robert Dale. Building applied natural language generation systems. Nat. Lang. Eng., 3(1):

57-87, March 1997. ISSN 1351-3249. doi: 10.1017/S135 1324997001502. URL/https://doi.org/10.1017/

81351324997001502

S. E. Robertson and S. Walker. Some simple effective approximations to the 2-poisson model for probabilistic weighted
retrieval. In Bruce W. Croft and C. J. van Rijsbergen, editors, SIGIR ’94, pages 232-241, London, 1994. Springer
London. ISBN 978-1-4471-2099-5.

Atanas Rountev and Dacong Yan. Static reference analysis for gui objects in android software. In Proceedings of
Annual IEEE/ACM International Symposium on Code Generation and Optimization, CGO 14, pages 143:143-
143:153, New York, NY, USA, 2014. ACM. ISBN 978-1-4503-2670-4. doi: 10.1145/2581122.2544159. URL

http://doi.acm.org/10.1145/2581122. 2544159

Sankardas Roy, Jordan DeLoach, Yuping Li, Nic Herndon, Doina Caragea, Xinming Ou, Venkatesh Prasad Ranganath,
Hongmin Li, and Nicolais Guevara. Experimental study with real-world data for android app security analysis using
machine learning. In Proceedings of the 31st Annual Computer Security Applications Conference, pages 81-90.
ACM, 2015.

Sevil Sen, Emre Aydogan, and Ahmet I Aysan. Coevolution of mobile malware and anti-malware. [EEE Transactions
on Information Forensics and Security, 13(10):2563-2574, 2018.

Tulian Vlad Serban, Alessandro Sordoni, Ryan Lowe, Laurent Charlin, Joelle Pineau, Aaron Courville, and Yoshua
Bengio. A hierarchical latent variable encoder-decoder model for generating dialogues. In Proceedings of the
Thirty-First AAAI Conference on Artificial Intelligence, AAAT 17, page 3295-3301. AAAI Press, 2017.

Xiaoyu Shen, Hui Su, Yanran Li, Wenjie Li, Shuzi Niu, Yang Zhao, Akiko Aizawa, and Guoping Long. A conditional
variational framework for dialog generation. In Proceedings of the 55th Annual Meeting of the Association for
Computational Linguistics (Volume 2: Short Papers), pages 504—509, Vancouver, Canada, July 2017. Association

26


A PREPRINT - JULY 8, 2021

for Computational Linguistics. doi: 10.18653/v1/P17-2080. URL \https://www.aclweb.org/anthology
P17- 2080)

Rocky Slavin, Xiaoyin Wang, Mitra Bokaei Hosseini, James Hester, Ram Krishnan, Jaspreet Bhatia, Travis D Breaux,
and Jianwei Niu. Toward a framework for detecting privacy policy violations in android application code. In
Proceedings of the 38th International Conference on Software Engineering, pages 25-36. ACM, 2016.

Statista. Number of apps available in leading app stores as of 2nd quarter 2019, 2019. (Visited August 2019) [Online].
Available: https://www.statista.com/statistics/276623/number-of-apps-available-in-leading-app-stores/.

Peter Story, Sebastian Zimmeck, Abhilasha Ravichander, Daniel Smullen, Ziqi Wang, Joel R. Reidenberg, N. Cameron
Russell, and Norman M. Sadeh. Natural language processing for mobile app privacy compliance. 2019.

Ilya Sutskever, Oriol Vinyals, and Quoc V. Le. Sequence to sequence learning with neural networks. In Proceedings of
the 27th International Conference on Neural Information Processing Systems - Volume 2, NIPS’ 14, pages 3104-3112,

Cambridge, MA, USA, 2014. MIT Press. URL/http://dl.acm. org/citation.cfm?id=2969033 .2969173

Symantec. Internet security threat report, 2017. (Visited October 2019) [Online]. Available:
https://www.symantec.com/content/dam/symantec/docs/reports/istr-22-2017-en.pdf.

Kimberly Tam, Ali Feizollah, Nor Badrul Anuar, Rosli Salleh, and Lorenzo Cavallaro. The evolution of android
malware and android analysis techniques. ACM Computing Surveys (CSUR), 49(4):76, 2017.

Peter Teufl, Michaela Ferk, Andreas Fitzek, Daniel Hein, Stefan Kraxberger, and Clemens Orthacker. Malware detection
by applying knowledge discovery processes to application metadata on the android market (google play). Security
and communication networks, 9(5):389-419, 2016.

Robert Tibshirani. Regression shrinkage and selection via the lasso. Journal of the Royal Statistical Society. Series B
(Methodological), 58(1):267-288, 1996. ISSN 00359246. URL http://www. jstor .org/stable/2346178
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, and Illia

Polosukhin. Attention is all you need. CoRR, abs/1706.03762, 2017. URL|http: //arxiv.org/abs/1706 .03762

Timothy Vidas and Nicolas Christin. Evading android runtime analysis via sandbox detection. In Proceedings of the
9th ACM symposium on Information, computer and communications security, pages 447-458. ACM, 2014.

Nicolas Viennot, Edward Garcia, and Jason Nieh. A measurement study of google play. In ACM SIGMETRICS
Performance Evaluation Review, volume 42, pages 221—233. ACM, 2014.

VirusShare. Virus share malware repository, 2019. (Visited September 2019) [Online]. Available:
https://virusshare.com/.

Haoyu Wang and Yao Guo. Understanding third-party libraries in mobile app analysis. In 20/7 IEEE/ACM 39th
International Conference on Software Engineering Companion (ICSE-C), pages 515-516. IEEE, 2017.

Haoyu Wang, Yao Guo, Ziang Ma, and Xiangqun Chen. Wukong: A scalable and accurate two-phase approach to
android app clone detection. In Proceedings of the 2015 International Symposium on Software Testing and Analysis,
pages 71-82. ACM, 2015.

Haoyu Wang, Yuanchun Li, Yao Guo, Yuvraj Agarwal, and Jason I Hong. Understanding the purpose of permission use
in mobile apps. ACM Transactions on Information Systems (TOIS), 35(4):43, 2017a.

Haoyu Wang, Junjun Si, Hao Li, and Yao Guo. Rmvdroid: towards a reliable android malware dataset with app
metadata. In Proceedings of the 16th International Conference on Mining Software Repositories, pages 404-408.
IEEE Press, 2019a.

Jiayu Wang and Qigeng Chen. Aspg: Generating android semantic permissions. In 2014 [EEE 17th International
Conference on Computational Science and Engineering, pages 591-598. IEEE, 2014.

Run Wang, Zhibo Wang, Benxiao Tang, Lei Zhao, and Lina Wang. Smartpi: Understanding permission implications of
android apps from user reviews. IEEE Transactions on Mobile Computing, 2019b.

Shanshan Wang, Qiben Yan, Zhenxiang Chen, Bo Yang, Chuan Zhao, and Mauro Conti. Detecting android malware
leveraging text semantics of network flows. [EEE Transactions on Information Forensics and Security, 13(5):
1096-1109, 2017b.

Wenqi Wang, Benxiao Tang, Run Wang, Lina Wang, and Aoshuang Ye. Towards a robust deep neural network in texts:
A survey. arXiv preprint arXiv: 1902.07285, 2019c.

Xiaoyin Wang, Xue Qin, Mitra Bokaei Hosseini, Rocky Slavin, Travis D Breaux, and Jianwei Niu. Guileak: Tracing
privacy policy claims on user input data for android applications. In Proceedings of the 40th International Conference
on Software Engineering, pages 37-47. ACM, 2018.

27


A PREPRINT - JULY 8, 2021

Takuya Watanabe, Mitsuaki Akiyama, Tetsuya Sakai, and Tatsuya Mori. Understanding the inconsistencies between
text descriptions and the use of privacy-sensitive resources of mobile apps. In Eleventh Symposium On Usable
Privacy and Security (SOUPS 2015), pages 241-255, Ottawa, 2015. USENIX Association. ISBN 978- 1-93 1971-249.

URL https: //www.usenix.org/conference/soups2015/proceedings/presentation/watanabe

Hacettepe University WISE Lab. Desre (descriptions and reviews) dataset, 2019. (Visited November 2019) [Online].
Available: https://wise.cs.hacettepe.edu.tr/projects/desre/dataset/.

Michelle Y Wong and David Lie. Intellidroid: A targeted input generator for the dynamic analysis of android malware.
In NDSS, volume 16, pages 21-24, 2016.

Tingmin Wu, Lihong Tang, Rongjunchen Zhang, Sheng Wen, Cecile Paris, Surya Nepal, Marthie Grobler, and Yang
Xiang. Catering to your concerns: Automatic generation of personalised security-centric descriptions for android
apps. ACM Transactions on Cyber-Physical Systems, 3(4):36, 2019.

Zhihua Xia, Xinhui Wang, Xingming Sun, and Qian Wang. A secure and dynamic multi-keyword ranked search scheme
over encrypted cloud data. IEEE transactions on parallel and distributed systems, 27(2):340-352, 2015.

Yinxing Xue, Guozhu Meng, Yang Liu, Tian Huat Tan, Hongxu Chen, Jun Sun, and Jie Zhang. Auditing anti-malware
tools by evolving android malware and dynamic loading technique. IEEE Transactions on Information Forensics and
Security, 12(7):1529-1544, 2017.

Xinli Yang, David Lo, Li Li, Xin Xia, Tegawendé F Bissyandé, and Jacques Klein. Characterizing malicious android
apps by mining topic-specific data flow signatures. Information and Software Technology, 90:27-39, 2017.

L. Yu, T. Zhang, X. Luo, L. Xue, and H. Chang. ty77. IEEE Transactions on Information Forensics and Security, 12(4):
865-880, April 2017. ISSN 1556-6013. doi: 10.1109/TIFS.2016.2639339.

Le Yu, Xiapu Luo, Xule Liu, and Tao Zhang. Can we trust the privacy policies of android apps? In 2016 46th Annual
IEEE/IFIP International Conference on Dependable Systems and Networks (DSN), pages 538-549. IEEE, 2016a.

Le Yu, Xiapu Luo, Chenxiong Qian, and Shuai Wang. Revisiting the description-to-behavior fidelity in android
applications. In 2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering
(SANER), volume 1, pages 415-426. IEEE, 2016b.

Le Yu, Xiapu Luo, Chenxiong Qian, Shuai Wang, and Hareton KN Leung. Enhancing the description-to-behavior
fidelity in android apps with privacy policy. IEEE Transactions on Software Engineering, 44(9):834—854, 2017.

Le Yu, Jiachi Chen, Hao Zhou, Xiapu Luo, and Kang Liu. Localizing function errors in mobile apps with user reviews.
In 2018 48th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN), pages
418-429. IEEE, 2018.

Xiaochun Yun, Yipeng Wang, Yongzheng Zhang, and Yu Zhou. A semantics-aware approach to the automated network
protocol identification. IEEE/ACM Transactions on Networking (TON), 24(1):583-595, 2016.

Chengpeng Zhang, Haoyu Wang, Ran Wang, Yao Guo, and Guoai Xu. Re-checking app behavior against app description
in the context of third-party libraries. In SEKE, pages 665-664, 2018a.

Lei Zhang, Zhemin Yang, Yuyu He, Zhenyu Zhang, Zhiyun Qian, Geng Hong, Yuan Zhang, and Min Yang. Invetter:
Locating insecure input validations in android services. pages 1165-1178, 10 2018b. doi: 10.1145/3243734.3243843.

Mu Zhang, Yue Duan, Qian Feng, and Heng Yin. Towards automatic generation of security-centric descriptions for
android apps. In Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security,
pages 518-529. ACM, 2015.

Wei Emma Zhang, Quan Z Sheng, AHOUD Alhazmi, and CHENLIANG LI. Adversarial attacks on deep learning
models in natural language processing: A survey. arXiv preprint arXiv: 1901.06796, 2019.

Yajin Zhou and Xuxian Jiang. Dissecting android malware: Characterization and evolution. In 20/2 IEEE symposium
on security and privacy, pages 95-109. IEEE, 2012.

Ziyun Zhu and Tudor Dumitras. Featuresmith: Automatically engineering features for malware detection by mining
the security literature. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications
Security, pages 767-778. ACM, 2016.

Ziyun Zhu and Tudor Dumitras. Chainsmith: Automatically learning the semantics of malicious campaigns by mining
threat intelligence reports. In 20/8 IEEE European Symposium on Security and Privacy (EuroS&P), pages 458-472.
IEEE, 2018.

Sebastian Zimmeck, Ziqi Wang, Lieyong Zou, Roger Iyengar, Bin Liu, Florian Schaub, Shomir Wilson, Norman Sadeh,
Steven Bellovin, and Joel Reidenberg. Automated analysis of privacy requirements for mobile apps. In 20/6 AAAI
Fall Symposium Series, 2016.

28


A PREPRINT - JULY 8, 2021

Sebastian Zimmeck, Peter Story, Daniel Smullen, Abhilasha Ravichander, Ziqi Wang, Joel Reidenberg, N. Russell, and
Norman Sadeh. Maps: Scaling privacy compliance analysis to a million apps. Proceedings on Privacy Enhancing
Technologies, 2019:66—-86, 07 2019. doi: 10.2478/popets-2019-0037.

29
