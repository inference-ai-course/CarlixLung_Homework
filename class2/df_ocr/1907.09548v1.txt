1907.09548v1 [cs.AI] 22 Jul 2019

1V

arX1

Under consideration for publication in Theory and Practice of Logic Programming 1

On the Equivalence Between Abstract Dialectical
Frameworks and Logic Programs

J. ALCANTARA and S. SA

Federal University of Ceara, Brazil
(e-mail: jnando@lia.ufc.br and samy@ufc.br)

J. ACOSTA-GUADARRAMA

Autonomous University of Juarez, Mexico
(e-mail: juan.acosta@uacj.mx)

submitted 1 January 2003; revised 1 January 2003; accepted 1 January 2003

Abstract

Abstract Dialectical Frameworks (ADF's) are argumentation frameworks where each node is as-
sociated with an acceptance condition. This allows us to model different types of dependencies
as supports and attacks. Previous studies provided a translation from Normal Logic Programs
(NLPs) to ADF'’s and proved the stable models semantics for a normal logic program has an
equivalent semantics to that of the corresponding ADF. However, these studies failed in iden-
tifying a semantics for ADF's equivalent to a three-valued semantics (as partial stable models
and well-founded models) for NEPs. In this work, we focus on a fragment of ADF, called
Attacking Dialectical Frameworks (ADF*s), and provide a translation from NLPs to ADF*s
robust enough to guarantee the equivalence between partial stable models, well-founded models,
regular models, stable models semantics for NLPs and respectively complete models, grounded
models, preferred models, stable models for ADF's. In addition, we define a new semantics for
ADF'*s, called L-stable, and show it is equivalent to the L-stable semantics for NLPs. This
paper is under consideration for acceptance in TPLP.

1 Introduction

Logic Programming and Formal Argumentation Theory are two different formalisms
widely used for the representation of knowledge and reasoning. The connection between
them is especially clear when comparing the semantics proposed to each formalism. The
first questions were raised and answered in (Dung 1995), the work that originally in-
troduced Abstract Argumentation Frameworks (AAF): it was shown how to translate
a Normal Logic Program (NEP) to an AAF and proved the stable models (resp. the
well-founded model) of an NEP correspond to the stable extensions (resp. the grounded
extension) of its corresponding AAF. Other advances were made when
pointed the equivalence between the complete semantics for AAF and the partial stable
semantics for NLPs. Those semantics generalize many others, wielding a plethora of re-
sults gathered in (Caminada et_al. 2015a). One equivalence formerly expected to hold,
however, could not be achieved: the correspondence between the semi-stable semantics
for AAFs and the L-stable semantics for NPs (Eiter_et_al. 1997).
Despite their success, AAF’ are not immune to criticisms. A contentious issue refers
to their alleged limited expressivity as they lack features which are common in almost


2 J. Alcantara and 8. Sé and J. Acosta-Guadarrama

every form of argumentation found in practice (Brewka and Woltran 2010). Indeed, in
AAFs the only interaction between atomic arguments is given by the attack relation.

With such a motivation, in they defined
Abstract Dialectical Frameworks (ADF's), a generalization of AA Fs, to express arbitrary
relationships among arguments. In an ADF, besides the attack relation, arguments may
support each other, or a group of arguments may jointly attack another while each
argument in the group is not strong enough to do so. Such additional expressiveness
arises by associating to each node (argument) its two-valued acceptance conditions which
can get expressed as arbitrary propositional formulas. The intuition is that an argument
is accepted if its associated acceptance condition is true.

A translation from NIPs to ADFs is given in (Brewka_and Woltran_ 2010), where
they showed Stable Models Semantics for NZPs has an equivalent semantics for ADF.
However, they did not identify a semantics for ADF's equivalent to a 3-valued semantics
(such as Partial Stable Models) for NEPs (Brewka and Woltran 2010) |Strass 2013).

In this work, we will not only identify such semantics, but we will also ascertain only
a fragment of ADFs, called Attacking Dialectical Frameworks (ADF*s), is needed. In
fact, we will adapt the translation from NLPs to Abstract Argumentation proposed in
to provide a translation from NLPs to ADF ts
to account for various equivalences between their semantics. That includes to prove the
equivalence between partial stable models, well-founded models, regular models, stable
models semantics for NEPs and respectively complete models, grounded models, pre-
ferred models, stable models for ADF. Also, we define a new semantics for ADF*s,
called L-stable (for least-stable), and show it is equivalent to the L-stable semantics for
NLPs (Eiter_et_al. 1997). Hence, our results allow us to apply proof procedures and
implementations for ADF's to NLPs and vice-versa.

The paper proceeds as follows. Firstly we recall the basic definition of ADF’s and NI Ps
as well as some of their well-established semantics. Next, we consider the Attacking Ab-
stract Dialectical Frameworks (ADF'‘s), a fragment of ADFs in which the unique relation
involving arguments is the attack relation. In Section[4] we show a translation from NI Ps
to ADF*s and prove the equivalence between partial stable models (NLPs) and com-
plete models (ADF*s), well-founded models (NLPs) and grounded models (ADF*s),
regular models (NPs) and preferred models (ADF*s), stable models (NLPs) and stable
models ADF*s, L-stable models (NLPs) and L-stable models (ADF‘s). In Section 5]
we compare our results with previous attempts to translate NEPs into ADF’s and ADF's
into NZIPs and we present a brief account on the main connections between NIPs and
Abstract Argumentation Frameworks (Dung 1995) /Assumption-Based Argumentation
Dung et al. 2009) as well as a comparison between ADF* and SETAF (Nielsen and
Parsons 3006 , an extension of A
round off with a discussion of the obtained results and pointer for future works.

Fs to allow joint attacks on arguments. Finally, we

2 Background

2.1 Abstract Dialectical Frameworks

Abstract_Dialectical Frameworks (ADF's) have been designed in (Brewka and Woltran
2010, |Brewka et_al. 2013) to treat arguments (called statements there) as abstract and


On the Equivalence Between ADF's and Logic Programs 3

atomic entities. One can see it as a directed graph whose nodes represent statements,
which can get accepted or not. Besides, the links between nodes represent dependencies:
the status (accepted/not accepted) of a node s only depends on the status of its parents
(par(s)), ie., the nodes with a direct link to s. We will restrict ourselves to finite ADFs:

Definition 1 (Abstract Dialectical Frameworks (Brewka_and Woltran 2010))
An abstract dialectical framework is a tuple D = (S, L,C’) where

e S isa finite set of statements (positions, nodes);

e LCS x Sis a set of links, and Vs € S, par(s) = {t € S | (t,s) € L};

e C = {C, | s €S} is a set of total functions C, : 2?¢") + {t,f}, one for each
statement s. C, is called the acceptance condition of s.

The function C, is intended to determine the acceptance status of a statement s, which
only depends on the status of its parent nodes par(s). Intuitively, s will be accepted if
there exists R C par(s) such that C,(R) = t, which means every statement in R is
accepted while each statement in par(s) — R is not accepted. The acceptance conditions
in C of an ADF D =(S,L,C) can as well be represented in two alternative ways:

e Any function C, € C can be represented by the set of subsets of par(s) leading to
acceptance, ie., Ct = {Ct | s eS}, where Ct = {RC par(s) | C,(R) = t}. We
will indicate this alternative by denoting an ADF as (S,L,C*).

e Any function C, € C can also be represented as a classical two-valued propositional
formula y, over the vocabulary par(s) as follows:

v= VitAarn A >]. (1)

Rect \acR bepar(s)—R

If C,(@) = t and par(s) = 0, we obtain y, = t. If there is no R C par(s) such
that C,(R) = t, then y, = f. By C” we mean the set {y,|s ¢ S}. We will
indicate this alternative by denoting an ADF as (S,L,C%). We also emphasize
any propositional formula y, equivalent (in the classical two-valued sense) to the
formula in Equation can be employed to represent Cs.

When referring to an ADF as (S,L,C*%), we will assume the acceptance formulas im-
plicitly specify the parents a node depends on. Then, the set L of links between statements
can be ignored, and the ADF can be represented as (S,C'’), where L gets recovered by
(t,s) € L iff t appears in ys. In order to define the different semantics for ADF's over the
set of statements S, we will resort to the notion of (3-valued) interpretations:

Definition 2 (Interpretations and Models (Brewka and Woltran 2010))

Let D = (S,C%) be an ADF. A 3-valued interpretation (or simply interpretation) over
S is a mapping v: S — {t,f,u} that assigns one of the truth values true (t), false (f)
or unknown (u), to each statement. Interpretations will be extended to assign values to
formulas over statements according to Kleene’s strong 3-valued logic (Kleene et_al. 1952):
negation switches t and f, and leaves u unchanged; a conjunction is t if both conjuncts
are t, it is f if some conjunct is f and it is u otherwise; disjunction is dual. A 3-valued
interpretation v is a model of D if for all s € S we have u(s) ¥ u implies v(s) = u(¥¢s).


4 J. Alcdntara and S. Sé and J. Acosta-Guadarrama

Sometimes we will refer to an interpretation v over S asaset V = {s|s € S and v(s) =
t}U{-s|s€S and v(s) =f}. Obviously, if neither s € V nor 7s € V, then v(s) = u.

Furthermore, the three truth values are partially ordered by <; according to their
information content: u <; t and u <; f and no other pair is in <;. The pair ({t,f, u} , <;)
forms a complete meet-semilatticd] with the meet operation 1. This meet can be read
as consensus and assigns tt =t, ff =f, and returns u otherwise.

The information ordering <; extends as usual to interpretations v,, vg over S such
that vi <; v2 iff vi(s) <; v2(s) for all s € S. The set of all 3-valued interpretations over S$
forms a complete meet-semilattice with respect to <;. The consensus meet operation
of this semilattice is given by (v1 Mv2)(s) = v1(s) Mv2(s) for all s € S. The least element
of this semilattice is the interpretation v such that v(s) = u for each s € S.

In (Brewka et_al. 2013), the semantics for ADF's were defined via an operator Ip:

Definition 3 ((p Operator (Brewka_et_al. 2013))
Let D = (S,L,C%) be an ADF and v be a 3-valued interpretation over S. We have

Tp(v)(s) =[ ]{wlys) | w € [ul2},
in which [v]2 = {w | v <; w and for each s € S,w(s) € {t, f}}.

Each element in [v]2 is a 2-valued interpretation extending v. The elements of [v]2
form an <;-antichain with greatest lower bound v =[ |[v]g. For each s € S, Ip returns
the consensus truth value for ys, where the consensus takes into account all possible
2-valued interpretations w extending v. If v is 2-valued, we get [v]2 = {v}. In this case,
T'p(v)(s) = v(¢s) and v is a 2-valued model for D iff [p(v) = v. As [v]2 has only 2-valued
interpretations, if y! is equivalent to y? in the classical two-valued sense, it is clear

1 2
[ ]{wes) | w € [el2} =[ ] {e(e) | w € [olo}.
That means when defining Ip operator, it does not matter the acceptance formula we
choose as far as it is equivalent in the classical 2-valued sense. In addition, Ip operator
can be employed to characterize also complete interpretations:

Definition 4 (Complete Interpretations (Brewka_et_al. 2013))
Let D = (S,L,C%) be an ADF and v be a 3-valued interpretation over S. We state v is
a complete interpretation of D iff v =Tp(v).

As shown in (Brewka and Woltran 2010), [pp operator is <;-monotonic. Then a <-
least fixpoint of [p is always guaranteed to exists for every ADF D. Note complete
interpretations of D are also models of D. For this reason, they are also called complete

models. The notion of reduct_borrowed from logic programming (Gelfond and Lifschitz
1988) is reformulated to deal with ADF's:

Definition 5 (Reduct (Brewka_et al. 2013))

Let D = (S,L,C%) be an ADF and v be a 2-valued model of D. The reduct of D
with uv is given by the ADF, D” = (Fy, L",C”), in which E, = {s € S| u(s) =t},
LY =LN(E, x Ey), and CY = {y? | 5 € Ey, and py’ = ¢,[b/f : v(b) = f]}; ie., in each
acceptance formula, y’, we replace in ys every statement b € S by f if v(b) =f.

1 A complete meet-semilattice is such that every non-empty finite subset has a greatest lower bound,
the meet; and every nonempty directed subset has a least upper bound. A subset is directed if any
two of its elements have an upper bound in the set.


On the Equivalence Between ADF's and Logic Programs 5

We can now define some of the main semantics for an ADF as follows:

Definition 6 (Semantics (Brewka_et al. 2013))
Let D = (S,L,C%) be an ADF, and v a model of D. We state that

e vis a grounded model of D iff v is the <;-least complete model of D.

e visa preferred model of D iff v is a <;-maximal complete model of D.

e visa stable model of D iff v is a 2-valued model of D such that v is the grounded
model of D” = (E,, L’,C”).

We proceed by displaying an example to illustrate these semantics:

Example 7

Consider the ADF, D = (S,C®), given by a[=0] b[-a] c[>bAe] d{>c] e|7d],
where S = {a,b,c,d,e}, and the acceptance formula of each s € S' is written in square
brackets on the right of s. As for the semantics for D, we have a) {a, =b}, {b, d, na, 7c, se}
and @) are its complete models; b) @ is its grounded model; c) {a,b}, {b, d, aa, 7c, se}
are its preferred models; d) {b, d, sa, 7c, se} is its unique stable model.

Notice some ADF's have no stable models. For instance, in an ADF whose unique
statement is a[—a], there is no stable model. Furthermore, an ADF can have more than
one stable model as the ADF represented by a[-b] and b[-a], in which {a, =b} and {b, sa}
are the stable models of D. In contrast, the grounded model is unique for each ADF (see

(Brewka and Woltran 2010) |Brewka et al. 2013)).

2.2 Normal Logic Programs

Now we will focus on propositional normal logic programs. We assume the reader is

familiar with the Stable Model Semantics (Gelfond and Lifschitz 1988).

Definition 8

A Normal Logic Program (NIP), P, is a set of rules of the form a ¢ aj,...,@m,not 01,
...,not b, (m,n € N), where a, a; (1 < i < m) and b; (1 < j < n) are atoms; not
represents default negation, and not b; is a default literal. We say a is the head of the
rule, and aj,...,@m,not bj,...,not b,, is its body. The Herbrand Base of P is the set
AB p of all atoms occurring in P.

A wide range of logic programming semantics can be defined based on the 3-valued
interpretations (for short, interpretations) of programs:

Definition 9 (Interpretation and Models (Przymusinski 1990)))

A 3-valued interpretation, J, of an NLP, P, is a total function I: HBp — {t,f,u}.
We say I is a model of P iff for each rule a ¢ ay,...,@m, not bj,..., not b, € P,
min {I(a1),...,[(@m), 7L(b1),..., aL (bn)} <¢ I(a), where -t = f, of = t and su=u.
When convenient, we will refer to an interpretation I of P asa set I = {a | HBp and
I(a) =t}U{-a|a€ HBp and I(a) =f}. If neither a € Z nor 7a € T, then I(a) = u.

Besides the information ordering <,, it is worth mentioning here the truth ordering <;,
given by f <; u <; t. The truth ordering <; extends as usual to interpretations [,, I,
over HBp such that I, <; Ig iff (a) <; Ig(a) for all a € HBp. We also emphasize the


6 J. Alcantara and 8. Sé and J. Acosta-Guadarrama

notions of model of a logic program and model of an ADF follow distinct motivations:
the models of a logic program are settled on <, whereas the models of an ADF are settled
on <;. In order to avoid confusions, we will let it explicit when referring to one of them.

Now we will consider the main semantics for ND Ps. Let I be a 3-valued interpretation
of a program P; take P/I to be the program built by the execution of the following steps:

1. Remove any a + @4,...,@m, not b1,...,not b, € P such that I(b;) = t for some i
(l<i<n);

2. Afterwards, remove any occurrence of not 6; from P such that I(b;) =f.

3. Then, replace any occurrence of not b; left by a special atom u (u ¢ HBp).

Note u is assumed to be unknown in each interpretation of P. As shown in (Przy-
musinski 1990), P/J has a unique <;-least 3-valued model, obtained by the WV operator:

Definition 10 (We2 Operator (Przymusinski 1990))

Let P be an NLP, I and J be interpretations of P and a € HBp an atom in P. Define

(J)(a) =tifaeay,...,a@m € P/I and for alli, 1 <i<m, J(a;) =t;

(J)(a) = f if for every a ¢ a1,...,@m € P/I, there exists i, 1 < i < m, such
that J(a;) =f;

e Ve (J)(a) = u otherwise.

Ny

Indeed, the <;-least model of a denoted by Qp(Z), is given by the least fixed point
of U 5 iteratively obtained as follows for finite logic programs:

wee a1
if
nA a8

in which | is an interpretation such that for each a € HBp, l(a) = f. According to

(Przymusinski 1990), there exists n € N such that Qp(1) = WE"*! = WL”. We now
I

IT
specify the logic programming semantics to be examined in this paper.

Definition 11
Let P be an NEP and I be an interpretation:

I is a partial stable model (PSM) of P iff I = Qp(Z) (Przymusinski 1990).

T is a well-founded model of P iff I is the <;-least PSM of P (Przymusinski 1990).
I is a regular model of P iff J is a <;-maximal PSM of P (Biter et_al. 1997).

I is a stable model of P iff J is a PSM of P where for each a € HBp, I(a) € {t,f}
(Przymusinski 1990).

e J isan L-stable model of P iff Iisa PSM of P with minimal {a € HBp | I(a) = u}
(w.r.t. set inclusion) among all partial stable models of P (iter et_al. 1997).

Example 12
Consider the NIP P:

b<c,not a a+ not b c+d p<c,d,not p p<nota de

Concerning the semantics of P, we have a) Partial stable models: {c,d}, {b, c,d, p, 7a}
and {a,c,d,—7b}; b) Well-founded model: {c,d}; c) Regular models: {b,c,d,p, 7a} and
{a,c,d, ab}; d) Stable model and L-Stable model: {b, c, d, p, aa}.


On the Equivalence Between ADF's and Logic Programs 7

In the next section, we will focus on a fragment of ADF’s, dubbed Attacking Abstract
Dialectical Frameworks (ADF), and in the sequel we will show that ADF*s are enough
to capture any semantics based on partial stable models as those above mentioned.

3 Attacking Abstract Dialectical Frameworks

Now we consider the Attacking Abstract Dialectical Frameworks (ADF*s), a fragment
of ADFs in which the unique relation involving statements is the attack relation. We may
note parenthetically some definitions related to ADF's become simpler when restricted
to ADF ts. We proceed by recalling the notions of supporting and attacking links:

Definition 18 (Supporting and Attacking Links (Brewka_and Woltran 2010))
Let D = (S,L,C) be an ADF. A link (r,s) € L is

supporting in D iff for no R C par(s) we have C,(R) =t and C,(RU {r}) =f.
attacking in D iff for no R C par(s) we have C,(R) =f and C,(RU {r}) =t.

Formally, a link (r,s) is redundant if it is both attacking and supporting. Redundant
links can be deleted from_an ADF as they mean_no real dependencies (Brewka and
Woltran 2010; Rei i> EGaSES an] WIESE OULU Te STS TST the ipo
lar Abstract Dialectical Frameworks (BADF), a subclass of ADF's in which every link

is either supporting or attacking. Now we regard a subclass of BADF's in which only
attacking links are admitted:

Definition 14 (ADF*)

An Attacking Abstract Dialectical Framework, denoted by ADFT, is an ADF (S,L,C)
such that every (r,s) € ZL is an attacking link. This means that for every s € S, if
C,(M) =t, then for every M’ C M, we have C,(M’) =t.

In an ADF* (S,L,C), for each s € S, its acceptance formula vy, can be simplified as
follows:

Theorem 15
Let D = (S,L,C*) bean ADF* and, for every s € S, we define C1" = {R € Ct | there is
no R' € Ct such that RC R’}. Then, for every s € S,

g= V \ >».

REC? bEpar(s)—R

Hence, in ADF*s, every acceptance formula corresponds to a propositional formula
in the disjunctive normal form, where each disjunct is a conjunction of negative atoms.
Notice replacing an acceptance formula by a two-valued equivalent one does not change
the complete semantics, and we are not interested in the three-valued models of the
ADF. The importance of these formulas will be evident below. Before, however, note
ADF does not prohibit redundant links. For instance, consider the ADF D = (S,L,C),
in which S = {a,b,c}, L = {(b,a), (c,a)} and Ct = {{b},0} and Cf = Ct = {0}. We
know D is an ADF* as both (b,a) and (c,a) are attacking links. In addition, (b, a) is
a redundant link as it is also supporting. Redundant links can be easily identified in
ADF*s:



8 J. Alcantara and 8. Sé and J. Acosta-Guadarrama

Theorem 16
Let D = (S,L,Ct) be an ADF*. A link (r,s) € L is redundant iff r € R for every
Recor,

A straightforward consequence from Theorem[I6]is that in ADF*s, every acceptance
formula y, in the disjunctive normal form as in Theorem [15] where each disjunct is a
conjunction of negative atoms, disregards redundant links:

Corollary 17

Let D = ($,L,C*) be an ADF*. For each s € S, ify. is \/ /\\ 7) and
REC" bepar(s)—R

L' = {(r,s) | ar appears in ys}, then L’ has no redundant link.

Example 18
Let us recall the ADF* D = (S,L,C) above in which S = {a,b,c}, L = {(b, a), (c,a)}
and Ct = {{b},0} and Cf = Ct = {0}. With the general representation for ys in

ADFs, in which for every s € S, ys = V \ al \ ab], we get al(bA
Rect \acR bEpar(s)—R

ac) V (abA 70)] b[t] c[t]. With the simpler representation for acceptance formulas
given by Theorem in which y; = V \ ab, we get a[-c} bit] c[t].

REC? bE par(s)—R
As expected, the redundant link (b, a) is not taken into account to define y, as 7c.

Alternatively, redundant links in ADF*s have the following property:

Theorem 19
Let D = ($,L,C*) be an ADF*, 5 € S; r € par(s) and Ct(r) = {ReECt|reR}.A
t
link (r,s) € L is redundant iff |Ct(r)| = el,
Thus, identifying redundant links in an ADFT has a sub-quadratic time complexity
on |Ct|:

Corollary 20
Let D = (S,L,C*) be an ADF*. Deciding if a link (r,s) € L is redundant can be solved
in sub-quadratic time on |C*}.

In contrast, identifying redundant links in ADF's is coNP-hard (Elmauthaler 2012).
In Subsection 2-1] ['p operator is employed to define the semantics for ADF. When
restricted to ADF*s, it assumes a simpler version:

Theorem 21
Let D = (S,L,C®) be an ADF*, v be a 3-valued interpretation over S, and for each
8s €S, %, is the formula V \ —b depicted in Theorem [15] It holds for every

REC be par(s)—R
s € S, Pp(v)(s) = v(¥s).

Besides being noticeably simpler when restricted to ADF*, this new characterization
of 'p might mean lower complexity of reasoning. In (Brewka et_al. 2013), the problem

of verifying whether a given interpretation is complete is proved to be DP-complete. In


On the Equivalence Between ADF's and Logic Programs 9

our case, owing to our definition of [p, this problem can get solved by assigning values
to formulas over statements according to Kleene’s strong 3-valued logic. This evaluation
procedure is similar to (and has the same complexity as) that for Boolean formulas, which
takes polynomial time (Buss 1987). We run this procedure for each statement in a given
ADF. Then, the overall algorithm runs in polynomial time. It is a promising result as
the complexity of many reasoning tasks on ADF s may likely have the same complexity
as standard Dung’s AAF’s (Dung 1995). A consequence from Theorem PI] is the stable
models of an ADF* D can get characterized as the two-valued complete models of D:

Theorem 22
Let D = (S,L,C*) be an ADF*. Then v is a stable model of D iff v is a 2-valued
complete model of D.

The main objective of this work is to show each semantics for NIPs presented in
Subsection2.2] has an equivalent one for ADF +. Then we need to define a new semantics
for ADF*, which will be proved in the next section to be equivalent to the L-stable
models semantics for NI Ps:

Definition 28 (L-stable)

Let D = (S,L,C®) be an ADF*, and v be a 3-valued interpretation of D. We say v is an
L-stable model of D iff v is a complete model with minimal unk(v) = {s € S | v(s) = u}
(w.r.t. set inclusion) among all complete models of D.

Note L-stable models semantics is defined for every ADF*t and the L-stable models
of an ADF* D will coincide with its stable models whenever D has at least one stable
model. Indeed we can see a stable model v as an L-stable model in which unk(v) = 9.

Example 24
Consider the ADF* D = (S,C®) given by

a|—b| bla] c[(ace A 7a) V (ne A ad)| d[-d] e[ne A —b],

where S = {a,b,c,d,e}, and the acceptance formula of each statement s € S is written
in square brackets on the right of s. As for the semantics of D, a) {a, ab}, {b, sa, se} and
) are its complete models; b) —) is its grounded model; c) {a, =b} and {b, aa, ne} are its
preferred models; d) D has no stable model; e) {b, sa, e} is its unique L-stable model.

Thus none of these semantics for ADF* are equivalent to each other. However, in the
sequel, we will show some equivalences between NLPs semantics and ADF* semantics.

4 Equivalence Between ADF and Logic Programs

We will show one particular translation from NLP to ADF* is able to account for a
whole range of equivalences between their semantics. This includes to prove the equiva-
lence between NLP partial stable models and ADF* complete models, NLP well-founded
models and ADF* grounded models, NLP regular models and ADF? preferred models,
NLP stable models and ADF* stable models, NLP L-stable models and ADF* L-stable
models. Our treatment is based on a translation from NEP to Abstract Argumentation
proposed in [Caminada et_al. 2015a), where each NEP rule is directly

translated into an argument. In contradistinction, we will adapt it to deal with ADF by


10 J. Alcantara and 8. Sé and J. Acosta-Guadarrama

translating each rule into a substatement, and then, substatements corresponding to rules
with the same head are gathered to constitute a unique statement. Taking a particular
NLP P, one can start to construct substatements recursively as follows:

Definition 25 (Substatement)
Let P be an NEP.

e Ifaisarule (fact) in P, then it is also a substatement (say r) in P with Concp(r) =
a, Rulesp(r) = {a} and Supp(r) = {}.

e Ifa + not bj,...,not b, is a rule in P, then it is also a substatement (say r)
in P with Concp(r) = a, Rulesp(r) = {a ¢ not bj,...,not b,} and Supp(r) =
{nb1,..., 7b}.

e Ifateay,...,4m,not b1,...,not b, isarule in P and for each a; (1 < i < m) there
exists a substatement r; in P with Concp(r;) = a; anda aj,...,@m,not b1,...,
not b,, is not contained in Rulesp(r;), then a ¢ 11,...,%m,not b1,...,not by,
is a substatement (say r) in P with Concp(r) = a, Rulesp(r) = Rulesp(r,) U
... URulesp(rm) U {a + ay1,...,@m,not b),...,not b,} and Supp(r) = Supp(ri)
U...U Supp(Tn) U {ab1,..., abn}.

e Nothing more is a substatement in P.

For a substatement r in P, Supp(r) is referred to as the support of r in P. Besides, for
each substatement r in P, we can also define Supp(r) iteratively as follows:

Supp (r) = 0
Sup} ‘tT! (r) = {nb1,..., bn} U Sup}, ‘(r1) U...U Sup} (rm)

such that r is a substatement a ¢ 11,...,%m,not b1,...,not b, in P,a« ay,...,am,
not b;,...,not b, € Rulesp(r) and Va; (1 < i < m) there exists a substatement r; in P
with Concp(r;) = a;. Note for each substatement r in P, 3k € N such that Supp(r) =
Sup} *(r). This notion of support is generalized to obtain the support of an atom in P:
Definition 26 (Support)

Let P be an NEP over a set A of atoms. For each a € A, we define the support of a in
P as Supp(a)={ Supp(r) | r is a substatement in P such that Concp(r) =a }.

Example 27
Consider the normal logic program P from Example [12]

b<c,not a a<not b c+d p<c,d,not p p+ not a de

We can obtain the following substatements:

rm: d& T3: p-72,7T1,n0t p T5: p<nota
TT]: CHT Ta: a¢—not b re: b< ro,not a.
Thus
Supp(ri) = { } Sup p(r3) = {7p} Supp(15) = {7a}
Supp(r2) = { } Supp(r4) = {7b} Supp(r6) = {7a}.
and

Supp(a) = {{7}} Supp(b) = {{>a}} Supp(p) = {{>P} , {7a}}
Supp(c) = {0} Supp(d) = {0}.

After that, we can construct the corresponding ADF as follows:


On the Equivalence Between ADF's and Logic Programs 11

Definition 28
Let P be an NEP over a set A of atoms. Define an ADF =(P) = (A, L,C*), in which

e L ={(b,a) | B € Supp(a) and =b € B};
° For each a € A, Ct = {B' C {be par(a)|-b ¢ B}|Be Supp(a) }.
We can prove the resulting ADF =(P) is indeed an ADF*:

Proposition 29
Let P be an NLP. The corresponding =(P) is an ADF*.

Hence, the acceptance condition for each statement in =(P) can be retrieved as follows:

Proposition 380
Let P be an NLP and =(P) = (A,L,C*) the corresponding ADF*. The acceptance
condition Yq for each a € A is given by

V ( \ ).
BeéSupp(a) \7beB

In particular, if Supp(a) = {0}, then y, =t and if Sup,(a) = 0, then y, =f.

Ya

Example 81

Recalling the NLP P in Example 27] we obtain ADF* =(P) = (A,L,C*), in which
A = {a,b,c,d,p}; L = {(b,a), (a,b), (p,p), (a,p)}; CE = Cf = Ch = Ch = {0} and
Cf = {{a}, {p} ,0}. The acceptance condition for each statement in E(P) is given below:

a8} Ba] elt] lt] ppv -~a).
Concerning the semantics of =(P), we have

e Complete models: {c,d}, {b, c,d, p, a} and {a, c,d, =b};
e Grounded model: {c, d};

e Preferred models: {b, c,d,p, a} and {a, c, d, 7b};

e Stable model and L-stable model: {b, c,d, p, 7a}.

Now we can prove one of the main results of this paper: Partial Stable Models are
equivalent to Complete Models.

Theorem 82
Let P be an NLP and =(P) be the corresponding ADF. v is a partial stable model of
P iff v is a complete model of E(P).

With this equivalence showed in Theorem [B2] the following results are immediate:

Theorem 33
Let P be an NLP and =(P) = (A, L, Ct) the corresponding ADF*. We have

v is a well-founded model of P iff v is a grounded model of E(P).
v is a regular model of P iff v is a preferred model of E(P).

v is a stable model of P iff v is a stable model of =(P).

v is an L-stable model of P iff v is an L-stable model of =(P).


12 J. Alcantara and 8. Sé and J. Acosta-Guadarrama

From Theorems[B2]and B3] we see the NEP P from Example[I2]and the corresponding
ADF* =(P) from ExampleBI]produce the same semantics. This result sheds light on the
connections between ADF's and NLPs. Until now, it was unclear if any ADF semantics
could capture a 3-valued one for NIPs. Theorem|33]ensures the translation from NIP to
ADF in Definition 28]is robust enough to guarantee at least the equivalence between any
semantics based on partial stable models (at the NLP side) with any semantics based on
complete models (at the ADF side).

5 Related Works

The relation between NLP and formal argumentation goes back to works such as (Prakken
and Sartor 1997,|Simari and Loui 1992)|Dung 1995). In the sequel, we will describe previ-

ous attempts to translate ADF's to NEPs (Subsection[.1) and NEPs to ADFs (Subsection
and the main connections between NIPs and other argument-based frameworks such
as Abstract Argumentation Frameworks (AAFs) (Dung 1995) and Assumption-Based Ar-

gumentation (ABA) (Dung et al. 2009) in Subsection 5.3] Afterwards, we compare an
extension of AAF, called SETAF (Nielsen and Parsons 2006), with ADF*.

5.1 From ADF to Logic Programming
As pointed out by (Strass 2013), there is a direct translation from ADF to NIPs:

Definition 84 ( )
Let = = (S,L,C*) be an ADF. Define the corresponding NLP P(=) = {s + a1,...@m,
not bi,...,not by | s € S,{a1,...dm}e€ Ct and {bi,...,bn} = par(s) — Pista + wos Bend He

Note the body of a rule for s is satisfied by an interpretation J whenever for some
RC Ct, the statements in R are t in J and the remaining parents of s are f in J.

Example 35
The NLP P(&) corresponding to the ADF = of Example[Zis given by

P(E) ={ ae not b d+ notc c+-e,notb b<-nota e¢+notd }.

An ADF & and the corresponding NEP P(=) are equivalent under various well-known
semantics (Strass 2013). Indeed, the complete models, grounded models, preferred models
and stable models of = correspond respectively to the partial stable models, grounded
models, regular models and stable models of P(&). This result allows us to say ADF's are
as expressive as NI Ps. From an NLP P, we obtain an ADF =(P) via Definition 28] and
then again an NLP P(=(P)) via Definition B4] Although P and P(=(P)) are equivalent
according to the aforementioned semantics, it is not guaranteed P = P(E(P)):

Recall the NEP P in Example[[2]and the corresponding ADF* =(P) in Example
From =(P) via Definition [34] we obtain the NEP P(&(P)) (note P 4 P(E(P))):

b< nota a¢not b Ce p<not p p<not a dt.

Similarly, from an ADF =, we can obtain the NEP P(=) (Definition B4), and then
again an ADF =(P(=)) (Definition 28). As above, they will be equivalent according to

= —

the aforementioned semantics, however, it does not guarantee = = &(P(&)).


On the Equivalence Between ADF's and Logic Programs 13

Recall the ADF = in Example [7] and the corresponding NEP P(=) in Example
From P(=) via Definition [28] we obtain the ADF =(P(&)) (note = 4 =(P(S))):

a[—b] b[-a] c[7b A 7d] d{>c] e[-d].

5.2 From Logic Programming to ADF

As we have mentioned, previous attempts to identify a semantics for ADF's equivalent

to a 3-valued semantics for NPs have failed (Brewka and Woltran_ 2010) |Strass 2013).

Definition 36 ((Brewka_and Woltran 2010))
Let P be an NEP over a set A of atoms. Define an ADF, =2(P) = (A, L,C*), in which

e L={(c,a)|aay,...,Gm,not b1,...,not b,€ Pand c € {aj,...,@m,b1,...,bn}};
e For each a € A, Ct = {B € par(a) | a © ay,...,Qm,not bj,...,not by €

Alternatively, we could define the acceptance condition of each a € A as

— VV (a, A+++ A Gm Abt A+++ A nbn). (2)

at-Q),...,Am not b1,....n0t b,E€P

As noted in (Strass 2013), by Definition the NEPs, P,) = {c <;b € not b;
a © bja © ch} and Py = {c+;b H not b;a + b,not ca + c,not b;a + b,c} produce
the same ADF: (22(Pi) = 2o(P2)). For any s € A, its corresponding acceptance con-
dition is c[t] b[=] alb V Al But the unique partial stable model (PSM) of P, is
{a,c}, whereas {c} is the unique PSM of P,. Hence, this translation is inadequate to
distinguish these two non-equivalent programs, according to PSMs. In contradistinction,
our translation works accordingly and produces respectively the ADF’s below, which
has the same semantics as their corresponding original programs: E(P,) is given by
c[t] bl] a[t V 7b], and =(P2) is given by c[t] bl] a|(—=bV 7c) V 7b]. How-
ever, when restricting to the class of NEPs where each rule is as a + not 0j,...,not bm,
m > 0, the translation of Definition B6] coincides with the translation of Definition 28]
and is robust enough to capture 3-valued semantics as PSM and well-founded models.

Proposition 37

Let P be an NEP, where each rule is either a fact or its body has only default literals as
ina not bj,...,not b,. Let E(P) be the ADF obtained from P via Definition 28]and
E5(P) the ADF obtained from P via Definition B6] Then =(P) = =2(P).

This result shows how Definition |[36}]could be employed to capture 3-valued semantics
as PSMs: firstly, one could take an NEP P and apply any program transformation (pre-
serving PSMs) that transforms an NIP into one as that of Proposition Bal Then, one
could apply the translation in Definition B6] to the resulting program (say P’) to obtain
=>(P’). From Proposition [37] it holds P and =(P’) have the same PSMs.

2 By Equation [2] for =2(P), we have ya = (bA 7c) V (ADA c)V (bAc) =bVe.
3 See (Brass and Dix 1995) for some program transformations.


14 J. Alcantara and 8. Sé and J. Acosta-Guadarrama

5.3 On the connections between Logic Programming and Argumentation

Logic programming has long served as an inspiration for argumentation theory. Indeed,
one can see the seminal work of Dung on Abstract Argumentation Frame-
works (AAFs)_as an abstraction of some aspects of logic programming. In (Caminada
these frameworks described in is able to account for the equivalences
between Partial Stable Models, Well-Founded Models, Regular Models, Stable Models
Semantics for NZPs and respectively Complete Models, grounded models, Preferred Mod-
els, Stable Models for 4A Fs. However, unlike we have done for ADF's, they have showed
that, with their proposed translation from NLIPs to AAFs, there cannot be a semantics
for AAFS8 equivalent to L-Stable Semantics for NIPs.

When translating AAFs to NIPs, the connection between their semantics is stronger
than when translating in the opposite direction as for any of the mentioned semantics
for AAFs; there exists an equivalent semantics for NLPs (Caminada et_al. 2015a).

In (Caminada_and Schulz 2017), the authors showed how to translate Assumption-
Based Argumentation (ABA) to

NIPs and how this translation can be reapplied for a reverse translation from NIPs

to ABA. Curiously, the problematic direction here is from ABA to NEP. In (Caminada
and Schulz a , they have showed that with their proposed translation, there cannot
em. uivalent to the

the semi-stable semantics (Caminada et al.

2015b, |Schulz and ‘Toni 2015

) for AB

5.4. A Comparison between SETAF and ADF*

In (Nielsen and Parsons 2006), they proposed an extension of Dung’s Abstract Argumen-
tation Frameworks (AA F%) to allow joint attacks on arguments. The resulting framework,
called SETAF, is displayed below:

Definition 88 ((Nielsen_and Parsons 2006))
A framework with sets of attacking arguments (SETAF) is a pair SF = (A, R), where A
is the set of arguments and R C (24 — ) x A is the attack relation.

In an AAF, the unique relation between arguments is given by the attack relation,
where an (individual) argument attacks another. In a SETAF (as well as in an ADF*),
the novelty is that a set of arguments can attack an argument. For a translation from
SETAF to ADF refer to (Polberg 2016):

Translation. Let SF = (A,R) be a SETAF. The ADF corresponding to SF is
DF*" = (A,L,C), where L = {(a,y) | 1X C A such that x € X and (X,y) € R},
C = {C,},a€A and every C, gets constructed in the following way: for every B C
par(a), if 4(X;,a) € R such that X; C B, then C,(B) = f; otherwise, C,(B) = t.

The following result is immediate:

Proposition 39
Let SF = (A, R) bea SETAF and DFS = (A, L,C) be the corresponding ADF’. Then,
DF°® is an ADF*.

On the other hand, not every ADF* will correspond to a SETAF according to the


On the Equivalence Between ADF's and Logic Programs 15

translation above. A noticeable difference between them is that for every argument a € A
ina SETAF SF = (A,R), it holds (0,a) ¢ R. Then, for every statement s in the
corresponding DF*", it holds C,(0) = t, while C,(0) = f is allowed in ADF*. Indeed,
when C,(0) =f in an ADF*, we have C,(R) =f for every R C par(s), ie., ys =f.

6 Conclusions and Future Works

In this paper, we have niece the connections heaves Abstract Dialectical Frame-
works (ADFs) and : works (Brewka and
Woltran 2010, |Strass 2013), we have provided a translation from NEPS to ADFs robust
enough to capture the equivalence between several frameworks for these formalisms,

including 3-valued semantics. In particular, after resorting to our translation, we have
proved the equivalence between partial stable models, well-founded models, regular mod-
els, stable models semantics for NIPs and respectively complete models, grounded mod-
els, preferred models, stable models for ADF’.

Curiously, we have obtained these equivalence results by translating an NLP into a frag-
ment of ADF, called Attacking Dialectical Frameworks (ADF*), in which the unique
relation involving statements is the attack relation. A distinguishing aspect of our transla-
tion when compared with related works as is that it
is made in two steps: in the first step each NEP rule is translated into a substatement, and
then, substatements corresponding to rules with the same head are gathered to constitute
a unique statement. With this procedure, our intention is to simulate the semantics for
NIPs, where the truth-value of an atom b is the disjunction of the truth-values of the
bodies of the rules whose head is b. Besides, we have defined a new semantics for ADFT,

called L-Stable, and showed it is equivalent to the L-Stable Semantics (defined in (Eiter
et al. 1997)) for NLPs.

An essential element to define these semantics for ADF is Ip, a kind of immediate
consequences operator. When restricted to ADF*, we have proved Ip is equivalent
to a noticeably simpler version. Indeed, owing to this simplicity, verifying whether a
given labelling is complete is of complexity P, whereas this verification problem is DP-
complete for ADF (Brewka et_al. 2013). This is a promising result as it might also mean
the complexity of many reasoning tasks on ADF*s may have the same complexity as
standard Dung’s Abstract Argumentation Frameworks (Dung 1995).

As future work, we intend to complete a thorough investigation of the connections
between ADF's and ADF*s. Regarding the equivalences between NLP and ADF*, one
can claim that ADF*s are as general as ADF, and the attack relation suffices to express
these relations involving statements in ADF’. Given the results unveiled in the current
paper, we also envisage unfolding the connections between NIPs and SETAFs (Nielsen
joint attacks on arguments. We expect that there are various correspondences between
their semantics.

References

BONDARENKO, A., Dunc, P. M., Kowa.ski, R. A., AND Toni, F. 1997. An abstract,
argumentation-theoretic approach to default reasoning. Art. Intelligence 98, 1-2, 63-101.


16 J. Alcdntara and S. Sé and J. Acosta-Guadarrama

Brass, S. AND Dix, J. 1995. Characterizations of the stable semantics by partial evaluation. In
International Conf. on Logic Programming and Nonmonotonic Reasoning. Springer, 85-98.
BREWKA, G., ELLMAUTHALER, S., STRASS, H., WALLNER, J. P., AND WOLTRAN, S. 2013.
Abstract dialectical frameworks revisited. In Proceedings of the Twenty-Third international

joint conference on Artificial Intelligence. AAAI Press, 803-809.

BREWKA, G. AND WOLTRAN, S. 2010. Abstract dialectical frameworks. In Twelfth International
Conf. on the Principles of Knowledge Representation and Reasoning. AAAI Press, 102-111.
Buss, S. R. 1987. The boolean formula value problem is in alogtime. In Proceedings of the

nineteenth annual ACM symposium on Theory of computing. ACM, 123-131.

CAMINADA, M. 2006. Semi-stable semantics. ist International Conference on Computational
Models of Argument (COMMA) 144, 121-130.

CAMINADA, M., SA, S., ALCANTARA, J., AND DvorAK, W. 2015a. On the equivalence be-
tween logic programming semantics and argumentation semantics. International Journal of
Approximate Reasoning 58, 87-111.

CAMINADA, M. AND SCHULZ, C. 2017. On the equivalence between assumption-based argumen-
tation and logic programming. Journal of Artificial Intelligence Research 60, 779-825.

CAMINADA, M. W. A., SA, S., ALCANTARA, J., AND DvoRAk, W. 2015b. On the difference
between assumption-based argumentation and abstract argumentation. [fCoLog Journal of
Logics and their Applications.

Duna, P. 1995. On the acceptability of arguments and its fundamental role in nonmonotonic
reasoning, logic programming and n-person games. Artificial Intelligence 77, 321-357.

Dunc, P. M., KowAtsk1, R. A., AND TONI, F. 2009. Assumption-based argumentation. In
Argumentation in artificial intelligence. Springer, 199-218.

EITER, T., LEONE, N., AND SaccA, D. 1997. On the partial semantics for disjunctive deductive
databases. Ann. Math. Artif. Intell. 19, 1-2, 59-96.

ELLMAUTHALER, S. 2012. Abstract Dialectical Frameworks: Properties, Complexity, and Im-
plementation. M.S. thesis, Technische Universitat Wien, Institut fiir Informationssysteme.
GELFOND, M. AND LIFSCHITZ, V. 1988. The stable model semantics for logic programming. In

Proc. of the 5th International Conference on Logic Programming (ICLP). Vol. 88. 1070-1080.

KLEENE, S. C., DE BRuIJN, N., DE GRooT, J., AND ZAANEN, A. C. 1952. Introduction to
metamathematics. Vol. 483. van Nostrand New York.

NIELSEN, S. H. AND PARSONS, S. 2006. A generalization of Dung’s abstract framework for
argumentation: Arguing with sets of attacking arguments. In International Workshop on
Argumentation in Multi-Agent Systems. Springer, 54-73.

POLBERG, S. 2016. Understanding the abstract dialectical framework. In EHuropean Conference
on Logics in Artificial Intelligence. Springer, 430-446.

PRAKKEN, H. AND SARTOR, G. 1997. Argument-based extended logic programming with de-
feasible priorities. Journal of applied non-classical logics 7, 1-2, 25-75.

PRZYMUSINSKI, T. C. 1990. The well-founded semantics coincides with the three-valued stable
semantics. Fundamenta Informaticae 13, 4, 445-463.

SCHULZ, C. AND TOoNI, F. 2015. Logic programming in assumption-based argumentation
revisited-semantics and graphical representation. In 29th AAAI Conf. on Art. Intelligence.
Sm™arI, G. R. AND Lou, R. P. 1992. A mathematical treatment of defeasible reasoning and

its implementation. Artificial intelligence 58, 2-3, 125-157.

STRASS, H. 2013. Approximating operators and semantics for abstract dialectical frameworks.
Artificial Intelligence 205, 39-70.

Tonl, F. 2014. A tutorial on assumption-based argumentation. Argument & Computation 5, 1,
89-117.

Wu, Y., CAMINADA, M., AND GABBAyY, D. M. 2009. Complete extensions in argumentation
coincide with 3-valued stable models in logic programming. Studia logica 93, 2-3, 383.


On the Equivalence Between ADF's and Logic Programs 17

Appendix A Proofs of Theorems
A.1 Theorems and Proofs from Section [3

Theorem 15
Let D = (S,L,C*) bean ADF" and, for every s € S, we define C"** = {R € Ct | there is
no R' € Ct such that RC R’}. Then, for every s € S,

v= Vo fA >.

REC?" bEpar(s)—R

Proof

According to Equation (), ys = yi = Vrect (Accr®A Asepar(s)—R +0). Let yo =
V recom Nvepar(s)—R 0 We will show 91 = $2, i.e., for any 2-valued interpretation v,
u(r) = v(y2):

e If v(yi) =t, then there exists R € Ct such that for all a € R, v(a) = t and for all
b € par(s) — R, v(b) = f. As there exists R’ € C?"** such that R C R’, we obtain
for all b € par(s) — R’, v(b) =f. Thus, v(y2) = t.

e If v(yi) = f, then for each R € Ct there exists a € R such that v(a) = f or
there exists b € par(s) — R such that v(b) = t. In particular, for each R € C7”
there exists a_€ R such that v(a) = f or there exists b € par(s) — R such that
u(b) = t, and4 there exists b € par(s) — R’ such that v(b) = t, in which R’ =
R—{a€e R| v(a) =f}. But then for each R € Cr" there exists b € par(s) — R
such that v(b) = t. Thus, v(y2) =f.

O

Theorem 16
Let D = (S,L,Ct) be an ADF*. A link (r,s) € L is redundant iff r € R for every
Recor,

Proof
(=)

If (r,s) € DE is a redundant link, then, in particular, it is a supporting link, i.e., for
every R C par(s), we have if R € Ct, then (RU {r}) € Ct.

By absurd, suppose there exists R € C?®” such that r ¢ R. This means R € Ct. But
then we obtain (RU {r}) € Ct. It is an absurd as R € C™.
(<=)

Assume for any R € Cl", we have r € R. By absurd, suppose (r,s) € LD is not
redundant. Then there exists R’ C par(s) such that C,(R’) = t and C,(R’ U {r}) =f.

As r € R for any R € C7", there exists R” € C7” such that R’U {r} C R” and
C,(R") = t. But then, as any link in L is attacking, we obtain C,(R’ U {r}) =t. An
absurd. O

4 As D is an ADF*, for each R € C™*, for each R’ C R, we have R’ € Ct.


18 J. Alcantara and 8. Sé and J. Acosta-Guadarrama

Corollary 17

Let D = ($,L,C*) be an ADF*. For each s € S, ify. is \/ \\ 7) and
REC bepar(s)—R

L' = {(r,s) | mr appears in ys}, then L’ has no redundant link.

Proof

The result is straightforward: from Theorem [I6] we know (r,s) € L is a redundant link

iff for any R € C7", we have r € R iff -r does not appear in V \ ab iff
REC?" bE par(s)—R

(r,s) ZL’. O

Theorem 19

Let D = (S,L,C*) be an ADF*, s € S; r € par(s) and Ci(r) = {RE CE|reR}. A

t
link (r,s) € L is redundant iff |Cf(r)| = CG |

Proof
The proof follows from the definition of ADF* , a property of Power Sets and the Principle
of Inclusion and Exclusion (PIE).

In D, for every s € S and M C par(s), if C,(M) = t, then C,(M’) = t for every
M’ C M (Definition [4). Then Ct = {S CR| RECT} = U{VP(R)| Rec},
where C7" = {R €Ct | there is no R’ € Ct such that R C R’} and §9(R) denotes the
power set of R.

Given a set S, we have |§9(S)| = 2/5! and that, for each r € S, r is an element of

21" subsets of S, i.e., of precisely half the subsets of S$. Then if re SMT, we have

2
that r is an element of al subsets of S, ees subsets of J and _ ” subsets of SOT.
PIE ensures that |§9(S) U P(T)| = |(S)| + |P(T)| — |S) A P(L)|, which, because
P(SAT) = P(S)N¥P(T), leads to |§(S)U/P(T)| = |§(9)| +]! (T)|—-|P(SAT)|. That is,
s oe)
ifr € SNOT, then |§2(S)U(T)| = 2/5! + 2/7! 2/597! and r is an element of + a —
a — [PsP sets in §9(S) U §9(T). By extension of PIE, if r € (){S1,-.., Sn},

2
|U{ 8 (S1),--, (Sn) }

then r is an element of —-——.~—— _ sets in U {(51),..., (Sn) }.
Let (r,s) be a redundant link, then, for all R € C™%*, we have r € R (Theorem [I6),
R) | REC?’ and rEeR t
ie, r € ()Cm". Then r is an element of [U{SPae | Rey and were} = \csl sets in

2
U{P(R) | REC™® andr € R} = Ct, ie. |Ct(r)| =/S!.

Corollary 20
Let D = (S,L,Ct) be an ADF*. Deciding if a link (r,s) € L is redundant can be solved
in sub-quadratic time on |C'*}.

Proof

Because |Cf(r)| = 1a where Ct(r) = {Re Ct|re R}, to find if (r,s) is a redundant
link, it suffices to check for each R € Ct, if r € R. For each R € Ct, checking if r €¢ R
can be done by checking, for each s € R, if s = r. Clearly, each R € Ct has at most
k = maz {|R| | RE UC™**} elements. Because C7” C Ct and Ct is subset-complete,
we have |Ct| > 2*. Then k is O(/n|Ct|), which means that deciding if a link (r,s) € L is
redundant is O(|Ct|.ln(|Ct|)). O


On the Equivalence Between ADF's and Logic Programs 19

Theorem 21

Let D = (S,L,C®) be an ADF*, v be a 3-valued interpretation over S$, and for each

s €S, y, is the formula V \ —b depicted in Theorem [15] It holds for every
RECr* bE par(s)—R

s €S,Tp(v)(s) = (yz).

Proof
For each s € S, let ys be
ab
RECT” bepar(s)—R
It is enough to prove for each s € S, v(ys) = []{w(ys) | w € [v]o}, where [vlog =
{w | w is two-valued and v <; w}. We have three possibilities:

e u(y~s) = t iff there exists R € C2” such that for each b € par(s) — R, v(b) =f

iff there exists R € C7"** such that for each b € par(s) — R, for each w € [v]e,

w(b) = f iff for each w € [v]2, w(ys) =t iff []{w(ys) | w € [vjo} =t.

u(ys) = f iff for each R € Ci", there exists b € par(s) — R such that v(b) = t

iff for each w € [v]2, for each R € Ci", there exists b € par(s) — R such that

w(b) = t iff for every w € [vjo, w(ys) =f iff [] {w(ys) | w € [vlo} =f.

v(ys) = u, then for each R € C?"**, there exists b € par(s) — R such that v(b) €

{t,u} and there exists R € C2"*" such that for each b € par(s) — R, it holds

u(b) € {f, u}. Hence,

— there exists w € [v]2 such that for each R € C2"**, there exists b € par(s) — R
such that w(b) =t. This means there exists w € [v]2 such that w(ys) = f;

— there exists w’ € [v]2, there exists R € C?2"** such that for each b € par(s) — R,
it holds w’(b) =f. This means there exists w € [v]z such that w(ys) = t.

But then we have []{w(ys) | w € [v]2} =u.

O

Theorem 22
Let D = (S,L,C%) be an ADF*. Then v is a stable model of D iff v is a 2-valued
complete model of D.

Proof

(=) Let v be a stable model of D. It is trivial v is a complete model of D as every stable
model is a complete model.

(<=)

Let v be a 2-valued complete model of D. We will show v is a stable model of D,
i.e., v is a grounded model of D’ = (E£,,L°,C”), in which E, = {s € S| v(s) = t},
L° =LN(&, x E,) and for every s € Ey, we set y? = ys[b/f : v(b) = f].

As v is a complete model of D, if v(s) = t, then v(Ys) = (V recm Nvepar(s)-R 2) =
t. This means there exists R € C?"** such that for each b € par(s) — R, v(b) =f. Thus,
for each s € E,,, y? = t. As consequence, FE, is the grounded extension of D”, i.e., v is a
stable model of D. O


20 J. Alcantara and 8. Sé and J. Acosta-Guadarrama

A.2 Theorems and Proofs from Section |4}

Proposition 29
Let P be an NLP. The corresponding =(P) is an ADF*.

Proof

Let =(P) = (A,L,C*) be the ADF corresponding to the NLP P over a set of atoms
A. By absurd, suppose =(P) is not an ADF*. This means there exists a link (b,a) € L
for which some R C par(a) we have O,(R) = f and C,(R Uv {b}) = t (Definition [13).
As C,(RU {b}) = t, from Definition 28] we obtain there exists B € Supp(a) such that
RU {b} C {c € par(a) | ac ¢ B}. Then we can say there exists B € Supp(a) such that
RC {c€ par(a) | ac ¢ B}. But then C,(R) =t. An absurd! O

Proposition 80
Let P be an NLP and =(P) = (A,L,C*) the corresponding ADF*. The acceptance
condition Ya for each a € A is given by

V ( \ ):
BeSsupp(a) \nbEB

In particular, if Supp(a) = {0}, then y, =t and if Sup,(a) = 90, then y, =f.

Ya

Proof
As 3(P) is an ADF*, we obtain from Theorem []5]that for every a € A,

V {| A >),

Recm \ bepar(a)—R

Il

Pa

where C7"** = {R € Cf | there is no R' € Ct such that RC R’}. From Definition] we
know C7” = {R C {b € par(a) | =b ¢g B} | B € Supp(a) and there is no R' € Ct such
that RC R'} = {{b € par(a) | ab g B} | B € min {Supp(a)}}, in which min {Sup p(a)}
returns the minimal sets (w.r.t. set inclusion) of Supp(a). Thus for every a € A,

Recm \bepar(a)—R Bemin{Supp(a)} \7bEB

But then, we obtain

Ill

Pa

V ( \ -) = ( \ »)
Bemin{Supp(a)} \7bEB BeSsupp(a) \7bEB

O

Theorem 82
Let P be an NLP and =(P) be the corresponding ADF. v is a partial stable model of
P iff v is a complete model of E(P).


On the Equivalence Between ADF's and Logic Programs 21

Proof
Let P be an NLP and =(P) = (A,L,C*) be the corresponding ADF*. Let v be a 3-
valued interpretation. We will prove v is a partial stable model of P iff v is a complete
model of =(P), i.e., Qp(v) = v iff for each a € A, v(a) = v(Ya).

We will prove by induction on j that for each a € A, wt (a) = t iff there exists

Supp(r) € Supp(a) such that for each x € Sup)’ (r), u(a) = t.

Base Case: We know wt '(a) =tiffaec f iff there is a rule a < not 01,...,not by €
P (n > 0) such that for each bj, (1 <i<n), v(b;) = f iff there exists Sup p(r) € Supp(a)
such that Sup}, '(r) = {-b),...,7b,} and for each 7b; € Sup} '(r), u(7b;) = t.

Inductive Hypothesis: Assume for each a’ € A, uh”(d) = t iff there exists Supp(r) €
Supp(a’) such that for each x € Sup!,"(r), u(x) = t.

Inductive Step: We will prove wi" (a) = t iff there exists Supp(r) € Supp(a) such
that for each « € Sup},"*1(r), v(x) = t:

We know wh Gy) = t iff there exists a + aj,...,@m € f such that for each a;, 1 <
i<m, wt" (ai) = t iff there exists a < aj,...,@m,not b,,...,not b, € P such that
for each a;, 1 <i <m, U1,"(a,) = t, and for each b;, 1 <j <n, v(b;) = f iff according
to the Inductive Hypothesis, there exists a + @j,...,@m,not bj,...,not b, € P such
that for each a;, 1 < i < m, there exists Supp(ri) € Supp(a;) such that for each
x € Supp’ (ri), v(x) = t, and for each bj, 1 < j < n, v(b;) = f iff there exists
a Q1,..-,Q4m,not bj,...,not b, € P and there are statements r, rj, (1 <i <m) in
P with Concp(r) = a and Concp(r;) = a; such that for each r;, for each x € Sup," (ri),
v(x) = t, and for each bj, 1 < 7 <n, v(7b;) = t iff there exists Supp(r) € Supp(a)

such that for each a € Suph,"*1(r), u(a) = t.

The above result guarantees for a 3-valued interpretation v of P, Qp(v)(a) = t iff there
exists B = Supp(r) € Supp(a) such that for each x € B, v(x) =t, ie.,

Qp(v)(a) =¢t iffv V (A ~) =t iff v(ya) =t. (Al)

BeESupp(a) \7bEB

Similarly now we will prove by induction on j that for each a € A, wt (a) # f iff
there exists Supp(r) € Supp(a) such that for each x € Sup}, (r), u(x) #f.

Base Case: We know vt (a) # f iff either a € f ora + u € — iff there exists a
rule a + not bj,...,not b, € P (n > 0) such that for each b;, (1 <i <n), v(b;) At
iff there exists Supp(r) € Supp(a) such that Sup} '(r) = {-b1,...,7b,} and for each
bi, (1 < i <n), v(b;) # t iff there exists Supp(r) € Supp(a) such that for each
ab; € Sup) '(r), v(ab;) ££.

Inductive Hypothesis: Assume for each a’ € A, vt"(a’) # f iff there exists Supp(r) €

P
Uv
<

Supp(a’) such that for each « € Sup," (r), v(x) ££.

Inductive Step: We will prove wt"! (a) ~ f iff there exists Supp(r) € Supp(a) such
that for each x € Sup!,""!(r), u(x) ¥ f:
We know wt”"*! (a) + f iff there exists a < a1,...,@m € f such that for each a;, 1 <


22 J. Alcantara and 8. Sé and J. Acosta-Guadarrama

i<m, wt” (as) # f iff there exists a < aj,...,@m,not b1,...,not b, € P such that
for each aj, 1 <i<m, wt" (a;) # f, and for each b;,1 <j <n, v(b;) At iff according
to the Inductive Hypothesis, there exists a < @1,...,@m,not b,,...,not b, € P such
that for each aj, 1 < i < m, there exists Supp(ri) € Supp(ai) such that for each
LE Sup}, "(r;), v(a) # f, and for each b;, 1 < j < n, v(b;) A t iff there exists
a+ @1,..-,Q4m,not b1,...,not b, € P and there are statements r, rj, (1 <i <m) in
P with Concp(r) = a and Concp(r;) = a; such that for each r;, for each x € Suph"(r;),
u(x) # f, and for each bj, 1 < 7 <n, v(7b;) # f iff there exists Supp(r) € Supp(a)
such that for each « € Sup}"*!(r), v(x) Af.

The above result guarantees for a 3-valued interpretation v of P, Qp(v)(a) # f iff there
exists B = Supp(r) € Supp(a) such that for each x € B, v(x) #f, ie.,

Op(v)(a) =f iff V (A ») =f iff v(ya) =f. (A2)

BeéSupp(a) \7bEB
From and (A2), we conclude v is a partial stable model of P iff for all a € A,

v(a) = Qp(v)(a) = v (Vsesup (a) Ayers ~b)) = (Ya), ie., v is a complete model of
BP). oO

Theorem 83
Let P be an NLP and =(P) = (A, L, Ct) the corresponding ADF*. We have

e v is a well-founded model of P iff v is a grounded model of =(P).
e vis a regular model of P iff v is a preferred model of E(P).

e visa stable model of P iff v is a stable model of =(P).

e v is an L-stable model of P iff v is an L-stable model of =(P).

Proof
This proof is a straightforward consequence from Theorem B2]

e v is a well-founded model of P iff v is the <,-least partial stable model of P iff
(according to Theorem 82) v is the <;-least complete model of =(P) iff uv is the
grounded model of E(P).

v is aregular model of P iff v is a <;-maximal partial stable model of P iff (according

to TheoremB2) v is a <;-maximal complete model of E(P) iff v is a preferred model

of E(P).

v is a stable model of P iff v is a partial stable model of P such that unk(v) =

{s€ S| v(s) = u} = 0 iff (according to Theorem[32) v is a complete model of =(P)

such that unk(v) = @ iff (based on Theorem[22) v is a stable model of =(P).

e v is an L-stable model of P iff v is a partial stable model of P with minimal
unk(v) = {s € S| v(s) = u} (w.r.t. set inclusion) among all partial stable models
of P iff (according to Theorem[2) v a complete model of =(P) with minimal unk(v)
among all complete models of P iff v is an L-stable model of =(P).

O


On the Equivalence Between ADF's and Logic Programs 23

A.3 Propositions and Proofs from Section [5}

Proposition 37

Let P be an NEP, where each rule is either a fact or its body has only default literals as
ina ¢ not bj,...,not b,. Let =(P) be the ADF obtained from P via Definition 28]and
=o(P) the ADF obtained from P via Definition Then &(P) = Eo(P).

Proof

Firstly, let P be an NIP defined over a set A of atoms, where each rule is like a <—
not b),...,not b,. We know from Definitions [25] and 26] Supp(a) = {{7b1,..., bn} |
a + not bj,...,not b, € P}. Then, according to Definition we obtain the ADF
=(P) = (A, L,C*), where

e L={(c,a)|a¢ not bi,...,not b, € P andceé {hy,...,bn}};
e Forae A, Ct={B' C {be par(a) |b ¢ {b1,..., bn} |a not bi,...,not by € P}}
= {B' C par(a)|a¢ not bj,...,not b, € P and {bi,...,bn} NB’ =O}.

According to Definition B6] we obtain the ADF =9(P) = (A, L2, C4), where

e In = {(c,a) | a not by,...,not b, € P andceé {hy,...,bn}} = L;
e For each a € A, C$, = {B’ © par(a) | a + not by,...,not by € P,{bi,...,dn} A
B= =C.

Hence, =(P) = =2(P). O

Proposition 89
Let SF = (A, R) be a SETAF and DF*" = (A,L,C) be the corresponding ADF. Then,
DF*" is an ADFT.

Proof
In order to show DF*" = (A,L,C) is an ADF*, we will guarantee any (r,s) € L is an
attacking link, i.e., for every B C par(s), if C,(BU {r}) =t, then C,(B) =t:

Suppose C,,(B U {r}) = t. Then according to the translation from SETAF to ADF,
there is no (X;,s) € R such that X; C BU {r}. Thus there is no (X;,s) € R such that
X; C B. This implies C,(B)=t. O
