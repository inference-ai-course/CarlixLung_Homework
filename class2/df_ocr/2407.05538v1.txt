2407.05538v1 [cs.AI] 8 Jul 2024

1V

arX

Under consideration in Theory and Practice of Logic Programming (TPLP) 1

On the Equivalence between Logic Programming
and SETAF

JOAO ALCANTARA

Federal University of Ceard, Brazil

RENAN CORDEIRO

Federal University of Ceard, Brazil

(e-mail: (renandcsc@alu.ufc. br)
SAMY SA

Federal University of Ceard, Brazil

(e-mail: |samy@ufc. br)

Abstract

A framework with sets of attacking arguments (SETA F) is an extension of the well-known Dung’s
Abstract Argumentation Frameworks (AAF's) that allows joint attacks on arguments. In this
paper, we provide a translation from Normal Logic Programs (NIPs) to SETAFs and vice versa,
from SETAFs to NLPs. We show that there is pairwise equivalence between their semantics,
including the equivalence between L-stable and semi-stable semantics. Furthermore, for a class
of NLPs called Redundancy-Free Atomic Logic Programs (RFALPs), there is also a structural
equivalence as these back-and-forth translations are each other’s inverse. Then, we show that
RFALPs are as expressive as NIPs by transforming any NLP into an equivalent RFALP through
a series of program transformations already known in the literature. We also show that these
program transformations are confluent, meaning that every NZP will be transformed into a
unique RFALP. The results presented in this paper enhance our understanding that NIPs and
SETAFs are essentially the same formalism. Under consideration in Theory and Practice of
Logic Programming (TPLP).

KEYWORDS: Abstract Argumentation, SETAF, Logic Programming Semantics, Program
Transformations

1 Introduction

Argumentation and logic programming are two of the most successful paradigms in arti-
ficial intelligence and knowledge representation. Argumentation revolves around the idea
of constructing and evaluating arguments to determine the acceptability of a claim. It
models complex reasoning by considering various pieces of evidence and their interrela-
tionships, making it a powerful tool for handling uncertainty and conflicting information.
On the other hand, logic programming provides a formalism for expressing knowledge
and defining computational processes through a set of logical rules.

In this scenario, the Abstract Argumentation Frameworks (AAF's) proposed by Dung
in his seminal paper have exerted a dominant influence over the devel-


2 J. Alcantara, R. Cordeiro and S. Sd

opment of formal argumentation. We can depict such frameworks simply as a directed
graph whose nodes represent arguments and edges represent the attack relation between
them. Indeed, in AAF’s, the content of these arguments is not considered, and the attack
relation stands as the unique relation. The simplicity and elegance of AAF’s have made
them an appealing formalism for computational applications.

In Dung’s proposal, the semantics for AAF’s are given in terms of extensions, which are
sets of arguments satisfying certain criteria of acceptability. Naturally, different criteria
of acceptability will lead to different extension-based semantics, including Dung’s origi-
nal concepts of complete, stable, preferred and grounded semantics foondlioonh, and
semi-stable semantics (Caminada cmc | A richer characterisation based
on labellings was proposed by Caminada and Gabbay to

describe these semantics. Differently from extensions, which explicitly regard solely the
accepted arguments, the labelling-based approach permits a more fine-grained setting,
where each argument is assigned a label in, out, or undec. Intuitively, we accept an
argument labelled as in, reject one labelled as out, and consider one labelled as undec
as undecided, meaning it is neither accepted nor rejected.

Despite providing distinct perspectives on reasoning and decision-making, argumenta-
tion and logic programming have clear connections. Indeed, we can see in Dung’s work
how to translate a Normal Logic Program (NIP) into an AAF’. Besides,
the author proved that stable models (resp. the well-founded model) of an NEP corre-
spond to stable extensions (resp. the grounded extension) of the associated AAF. These
results led to several studies concerning

connections between argumentation and logic
programming (Dung |1995at 200% [Wu et al. 2011
2015b _In particular, (Wu et al. estab-

lished the equivalence between complete semantics and partial stable semantics. These

semantics generalise a series of other relevant semantics for each system, as extensively

documented in (Caminada et_al/2015b). However, one equivalence formerly expected to
(Caminadal

hold remained elusive: the correspondence between the semi-stable semantics (

in AAF and the L-stable semantics in NLP (Eiter et al. could not be at-
tained. They even showed in (Caminada et_al][2015b) that with their proposed transla-
tion from NIPs to AAFs, there cannot be a semantics for AAF's equivalent to L-stable
semantics.

In 2017) the authors showed how to translate Assumption-
Based Argumentation (ABA) (Bondarenko et.al. 2014)
to NEPs and how this translation can be reapplied for a reverse translation from
NLIPs to ABA. Curiously, the problematic direction here is from ABA to NEP. In
(Caminada and Schulz , they have shown that with their translation, there can-
not be a semantics for NIPs equivalent to the semi-stable semantics

Schulz and Toni for ABA.

Since then, a great effort has been made to identify paradigms where semi-stable and
L-stable semantics are equivalent. In (Alcantara et_al. , the strategy was to look

for more expressive argumentation frameworks than AAF's: Attacking Dialectical Frame-
works, a support-free fragment of Abstract Dialectical Frameworks (Brewka and Woltra
2010; |[Brewka et_al. , a generalisation of AAFs designed to express arbitrary

relationships among arguments. A translation from NIP to ADF* was proved in
(Alcantara et_al. to account for various equivalences between their semantics, in-


On the Equivalence between Logic Programming and SETAF 3

cluding the definition of a semantics for ADF* corresponding to the L-stable semantics
for NIPs.

In a similar vein, other relevant proposals explored the equivalence between L-stable
and_semi-stable semantics for Claim-augmented Argumentation Frameworks (CAF)
sation of AAF's where each argument is explicitly associated with a claim, and for Bipo-
lar Argumentation Frameworks (BAF’s) with conclusions Rocha and Cozmad 20220)
a generalisation of CAF’s with the inclusion of an explicit notion of support between
arguments. In both frameworks, the equivalence with NZIPs does not just involve their
semantics; it is also structural as there is a one-to-one mapping from them to NPs.

In (4 and Alcantaral 20214), instead of looking for more expressive argumentation
frameworks, the idea was to introduce more fine-grained semantics to deal with AAFs.
Then a five-valued setting was employed rather than the usual three-valued one. As in
the previous cases, this approach also captures the correspondence between the seman-
tics for AAF’s and NIPs. Specifically, it captures the correspondence involving L-stable
semantics.

The connections between ABA and logic programming were later revisited in
(S4 and AlcAntaral2019-|2021), where they proposed a new translation from ABA frame-
works to NPs. The correspondence between their semantics (including L-stable) is ob-
tained by selecting specific atoms in the characterisation of the NEP semantics.

In summary, in the connections between NZP and argumentation semantics, the
Achilles’ heel is the relation between L-stable and semi-stable semantics.

In this paper, we focus on the relationship between logic programming and SETAF
fNislson and Possond 200d an extension of Dung’s AAF's to allow joint attacks on
arguments. Following the strategy adopted in
2019) we resort to the characterisation of the SETAF semantics in terms of labellings
ih we sono (2019). As a starting point, we provide a mapping from NDI Ps to

SETAFs (and vice versa) and show that NLPs and SETAFS are pairwise equivalent un-
der various semantics, including the equivalence between L-stable and semi-stable. These

results were inspired directly by two of our previous works: the equivalence between NI Ps
na ADEs (Akt a and the equivalence between ADF*s and SETAFs
(AlcAntara and $a|2021).

Furthermore, we investigate a class of NPs called Redundancy-Free Atomic Logic
Programs (RFALPs) 2022). In RFALPs, the translations from NLPs to
SETAFs and vice versa preserve the structure of each other’s theories. In essence, these
translations become inverses of each other. Consequently, the equivalence results concern-
ing NEPs and SETA Fs have deeper implications than the correspondence results between
NLIPs and AAF's: they encompass equivalence in both semantics as well as structure.

Some of these results are not_new_as recently they have already been obtained in-
dependently by Konig et al. . In fact, their translation from NDPs
to SETAF’s and vice versa coincide with ours, and the structural equivalence between
RFALPs and SETAFs has also been identified there. However, their focus differs from
ours. While their work establishes the equivalence between stable models and stable ex-
tensions, it does not explore equivalences involving labelling-based semantics or address
the controversy relating semi-stable semantics and L-stable semantics, which is a key


4 J. Alcantara, R. Cordeiro and S. Sd

motivation for this work. In comparison with Konig et al.’s work, the novelty of our
proposal lies essentially in the aspects below:

e Our proofs of these results follow a significantly distinct path as they are based
on properties of argument labellings and are deeply rooted in works such as
[Alcantara and sl202n,

e We prove the equivalence between partial stable, well-founded, regular, stable, and
semi-stable model semantics for NEPs and respectively complete, grounded, pre-
ferred, stable, and semi-stable labellings for SETAFs. In particular, for the first
time, an equivalence between L-stable model semantics for NZPs and semi-stable
labellings for SETA F's is established.

e We provide a more in-depth analysis of the relationship between NEPs and SETA Fs.
Going beyond just proving semantic equivalence, we define functions that map
labellings to interpretations, and interpretations to labellings. These functions allow
us to see interpretations and labellings as equivalent entities, further strengthening
the connections between NIPs and SETAFs. In substance, we demonstrate that
the equivalence also holds at the level of interpretations/labellings.

The strong connection we establish between interpretations and labellings opens doors
for future exploration. This extends the applicability of our equivalence results to novel
semantics beyond those investigated here, potentially even encompassing multivalued
settings. This holds particular significance for the logic programming community. Well-
established concepts from argumentation, such as argument strength
(2018), can now be translated and investigated within the context of logic programming.
This underscores the value of our decision to employ labellings instead of extensions as
a more suitable approach to bridge the gap between NDPs and SETAFs.

Our research offers another key contribution, particularly relevant to the logic pro-
gramming community: it explores the expressiveness of RFALPs. We demonstrate that
a specific combination (denoted by + yrpm) of program transformations can transform
any NIP into an RFALP with exactly the same semantics. In simpler terms, RFALPs
possess the same level of expressiveness as NZPs. Although each program transforma-
tion in + yrpm was proposed by Brass and Dix 11999), the
combination of these program transformations (to our knowledge) has not been inves-

tigated yet. Then we establish several properties of > yrpy. Amongst other original
contributions of our work related to +urpm, we highlight the following results:

e Given an NEP, if repeatedly applying + yrpy leads to a program where no further
transformations are applicable (irreducible program), then the resulting program
is guaranteed to be an RFALP.

e We show that + yrpy is confluent, i.e., given an NLP, it does not matter the order
by which we apply repeatedly these program transformations, whenever we arrive
at an irreducible program, they will always result in the same RFALP (and in
the same corresponding SETAF). Hence, besides NZPs and RFALPs being equally
expressive, each NLP is associated with a unique RFALP.

e The SETAF corresponding to an NEP is invariant with respect to 4 urpm, i-e., if
P> is obtained from P; via ++yrpm (denoted by Pi +yurpm Pz), both P; and P,
will be translated into the same SETAF.


On the Equivalence between Logic Programming and SETAF 5

e We show that + yrpy preserves the semantics for NZPs studied in this paper: if
Pi }urpm P2, then P, and P2 have the same partial stable models, well-founded
models, regular models, stable models, and L-stable models.

The structure of the paper unfolds as follows: in Section] we establish the fundamen-
tal definitions related to SETAFs and NIPs. In Section [B] we adapt the procedure from
to translate NIPs into SETA Fs, and sub-
sequently, in the following section, we perform the reverse translation from SETAFs to
NTPs. In both directions, we demonstrate that our labelling-based approach effectively
preserves semantic correspondences, including the challenging case involving the equiva-
lence between semi-stable semantics (on the SETA Fs side) and L-stable semantics (on the
NLPs side). In Section] we focus on RFALPs and reveal that, when restricted to them,
the translation processes between NIPs and SETAFS are each other’s inverse. Then, in
Section [6] we guarantee that RFALPs are as expressive as NLPs. We conclude the pa-
per with a discussion of our findings and outline potential avenues for future research
endeavours.

The proofs for all novel results are presented in|Appendix A

2 Preliminaries

2.1 SETAF

In (Nielsen_and Parson , an extension of Dung’s Abstract Argumentation Frame-
works (AAF's) (Dung |1995b) to allow joint attacks on arguments was proposed. The
resulting framework, called SETAF, is defined next:

Definition 1 (SETAF (Nielsen and Parsons|2004))

A framework with sets of attacking arguments (SETAF for short) is a pair 21 = (A, Ait),
in which J is a finite set of arguments and Att C (24\ {0}) x A is an attack relation such
that if (B,a) € Att, there is no B’ C B such that (B’,a) € Ait, ie., B is a minimal set
(w.r.t. C) attacking di By Att(a) ={BCA| (B,a) € Att}, we mean the set of attackers
of a.

In AAF’s, only individual arguments can attack arguments. In SETAFs, the novelty is
that sets of two or more arguments can also attack arguments. This means that SETA Fs
(A, Att) with |B| = 1 for each (B,a) € Att amount to (standard Dung) AAFs.

The semantics for SETAFs are generalisations of the corresponding semantics for AA F's
(vielen and Eassoudl200d, ang can be defined equivalently in terms of extensions or
labellings (Flouris and Bikakis (2019). Our focus here will be on their labelling-based

semantics.

Definition 2 (Labellings (Flouris and Bikakis (2019))
Let 2 = (2, Att) be a SETAF. A labelling is a function £: A > {in, out, undec}. It is
admissible iff for each a € A,

e If £(a) = in, then for each B € Ait(a), it holds £(b) = out for some b € B.

1 In the original definition of SETA Fs in (Nielsen and Parsons|2006), attacks are not necessarily subset-

minimal.


6 J. Alcantara, R. Cordeiro and S. Sd

If £(a) = out, then there exists B € Att(a) such that £(b) = in for each b € B.
A labelling £ is called complete iff it is admissible and for each a € A,

If £(a) = undec, then there exists B € Att(a) such that £(b) 4 out for each b € B, and
for each B € Att(a), it holds £(b) # in for some b € B.

We write in(£) for {a€ A| L(a) = in}, out(L) for {a € A | L(a) = out}, and
undec(L) for {a € A| £(a) = undec}. As a labelling essentially defines a partition among
the arguments, we sometimes write £ asa triple (in(L), out (L), undec(L)). Intuitively, an
argument labelled in represents explicit acceptance; an argument labelled out indicates
rejection; and one labelled undec is undecided, i.e., it is neither accepted nor rejected.
We can now describe the SETAF semantics studied in this paper:

Definition 8 (Semantics (Flouris and Bikakis (2019))

Let 2 = (A, Att) be a SETAF. A complete labelling L is called

grounded iff in(£) is minimal (w.r.t. C) among all complete labellings of 2.
preferred iff in(£) is maximal (w.r.t. C) among all complete labellings of 2.
stable iff undec(L) = 0).

semi-stable iff undec(L) is minimal (w.r.t. C) among all complete labellings of 2.

Let us consider the following example:

Example 1
Consider the SETAF 2 = (A, Att) below:

© =@)

o() CaP

Fig. 1: A SETAF %

Concerning the semantics of 21, we have

Complete labellings: £; = (0,0, {a,b,c,d,e}), Lo = ({a},{b},{c,d,e}) and L3 =
({0} {a,c}, {e,d}):

Grounded labellings: £; = (@, 9, {a, b,c, d, e});

Preferred labellings: Lz = ({a}, {b}, {c,d,e}) and L3 = ({b}, {a, e}, {c, d});

Stable labellings: none;

Semi-stable labellings: £3 = ({b}, {a, e}, {c, d}).

2.2 Logic Programs and Semantics

Now, we take a look at propositional Normal Logic Programs. To delve into their defini-
tion and semantics, we will follow the presentation outlined in (Caminada et_al.)|2015b),

which draws from the foundation laid out in (Przymusinskill1990).


On the Equivalence between Logic Programming and SETAF 7

Definition 4 ( 20150))

A rule r is an expression
r:C€Q1,.--,4m,not b1,...,not by, (1)

where (m,n > 0); c, each a; (1 < 4 < m) and each 6; (1 < j < n) are atoms, and
not represents negation as failure. A literal is either an atom a (positive literal) or a
negated atom not a (negative literal). Given a rule r as above, c is called the head of
r, which we denote as head(r), and body(r) = {a1,...,@m,not b1,...,not b,} is called
the body of r. Further, we divide body(r) into two sets body*(r) = {a1,...,am} and
body” (r) = {not bj,...,not b,}. A fact is a rule where m = n = 0. A Normal Logic
Program (NEP) or simply a program P is a finite set of rules. If every r € P has
body~(r) = @, P is a positive program. The Herbrand Base of P is the set HB p of all
atoms appearing in P.

A wide range of NEP semantics are based on the 3-valued interpretations of programs
1900):
Definition 5 (3-Valued Herbrand Interpretation 1996))

A 3-valued Herbrand Interpretation Z (or simply interpretation) of an NEP P is a pair
(T, F) with T,F C HBp and TF = 9. The atoms in T are true in T, the atoms in
F are false in Z, and the atoms in HBp \ (T U F) are undefined in Z. For convenience,
when the NIP P is clear from the context, we will refer to the set of undefined atoms in
HBp\ (TUF) simply as TU F.

Now we will consider the main semantics for NLPs. Let I = (T,F) be a 3-valued
Herbrand interpretation of an NEP P; the reduct of P with respect to Z (written as
P/T) is the NEP constructed using the following steps:

1. Remove any a + @1,...,@m, not bj,...,not b, € P such that b; € T for some j
(l<j<n);

2. Afterwards, remove any occurrence of not b; from P such that b; € F;

3. Then, replace any occurrence of not 6; left by a special atom u (u ¢ HBp).

In the above procedure, u is assumed to be an atom not in HBp which is undefined
in all interpretations of P (a constant). Note that P/T is a positive program since all
negative literals have been removed. As a consequence, P/T has a unique least 3-valued

model (Przymusinski 1990), obtained by the W operator:
Definition 6 (W Operator 1990))

Let P be a positive program and J = (T,F) be an interpretation. Define Up(7) =
(T', F’), where

c €T’ iff c € HBp and there exists c ¢ a1,...,@m € P such that for all i, 1 <i<m,
a, € T;

c € F’ iff c € HBp and for every c + aj,...,@m € P, there exists 7, 1 <7 < m, such
that a; € F.


8 J. Alcantara, R. Cordeiro and S. Sd

The least 3-valued model of P is given by ule (Przymusinski 1990 , the least fixed
point of Vp iteratively obtained as follows:
Wp” = (0, HBp)
wp) =Up(Up)

t<w i<w
where w denotes the first infinite ordinal.
We can now describe the logic programming semantics studied in this paper:

Definition 7

Let P be an NEP and T = (T, F) be an interpretation; by Qp(Z) = wt”, we mean the
a,

least 3-valued model of £. We say that

T is a partial stable model of P iff Op(Z) =T (Przymusinskill1990).

T is a well-founded model of P iff Z is a st stable model of P where there is no
partial stable model Z’ = (T", F’) of P such that_T’ C T, ie., T is minimal (w.r.t. set
inclusion) among all partial stable models of P (Przymusinskdl1990).

ZT is a regular model of P iff Z is a partial stable model of P where there is no partial
stable model Z’ = (T", F’) of P such that TC a ve e. 7 is maximal (w.r.t. set inclusion)

among all partial stable models of P (

Ti ——or a (2- a vdioad stable model of P iff Zis a tial abl model of P where TUF = HBp
Przymusinskil|1990

F is an L-stable soda of P iff Z is a partial stable model of P where there is no partial
stable model Z’ = (T’, F’) of P such that TUF Cc T' UF", ie., TUF is maximal (w.r.t.

set inclusion) among all partial stable models of P ,

Although some of these eons aren are not ‘oah in logic programming literature,

their equivalence is proved in . This format helps us to relate

NLP and SETAF semantics n (Gaminada e-a to the = similarities between Definition [7] and
Definitions 2] and] We illustrate these semantics in the following example:

Example 2

Consider the following logic program P:
Ty: aenotb rg: be nota rg: eC nota,notc
Ta: C-notc,notd r5: d<notd Tg: e€< not b,note

This program has

Partial Stable Models: M, = (0,0), M2 = ({a}, {b}) and M3 = ({b}, {a, e});
Well-founded model: M, = (0,0);

Regular models: Mz = ({a}, {b}) and Ms = ({b}, {a, e});

Stable models: none;

L-stable model: M3 = ({b}, {a, e}).


On the Equivalence between Logic Programming and SETAF 9

3 From NIP to SETAF

In this section, we revisit the three-step process of argumentation framework instan-
tiation as employed in for translating an NIP into an AAF.
This method is based on the approach introduced b (Wu et_al, 2009) and shares sim-
ilarities with the procedures used in ASPIC (Caminada and Amgoud and
2011

2011). Its first step involves taking
an NIP and constructing its associated AAF. Then, we apply AAF semantics in the
second step, followed by an analysis of the implications of these semantics at the level
of conclusions (step 3). In our case, starting with an NLP P, we derive the associated
SETAF (Ap, Attp). Unlike the construction described in (Caminada et. alll2015b), rules
with identical conclusions in P will result in a single argument in Ap. This distinction is
capital for establishing the equivalence results between NDPs and SETA Fs. Additionally,
it simplifies steps 2 and 3, making them more straightforward to follow. We now detail
this process.

logic-based argumentation (

3.1 SETAF Construction

We will devise one translation from NEP to SETAF that is sufficiently robust to guar-
antee the equivalence between various kinds of NZPs models and SETAFs labellings.
Specifically, our approach will establish the correspondence between partial stable mod-
els and complete labellings, well-founded models and grounded labellings, regular models
and preferred labellings, stable models and stable labellings, L-stable models and semi-

stable labellings. Our method is built upon a translation from NIP to AAF proposed
in Ieorninada. et alloaish, where NIP rules are directly translated into arguments. We
will adapt this approach for SETAF by employing the translation method outlined in
to construct statements, and then statements corresponding to
rules with the same head will be grouped to form a single argument. Taking an NDP P,
we can start to construct statements recursively as follows:

Definition 8 (Statements and Arguments)
Let P be an NIP.

If c+ not bi,...,not b, is a rule in P, then it is also a statement (say s) with

— Conc(s) =c,

— Rules(s) = {c< not bj,...,not by},
— Vul(s) = {b1,...,bn}, and

— Sub(s) = {s}.

If c © a,...,Q@m,not b1,...,not b, is a rule in P and for each a; (1 < i < m) there
exists a statement s; with Conc(s;) = a; and c ¢ aj,...,@m,not b1,...,not b, is not
contained in Rules(s;), then c « (s1),...,(Sm), not b1,...,not b, is a statement (say
s) with

— Conc(s) =c,

— Rules(s) = Rules(s;) U...URules(sm) U{c a,...,@m,not by,...,not bp}
— Vul(s) = Vul(s1) U...U Vul(s,) U {b1,...,6n}, and

— Sub(s) = {s} USub(s,) U... USub(s,,).


10 J. Alcdntara, R. Cordeiro and S. Sé

By Gp we mean the set of all statements we can construct from P as above. Then we
define Ap = {Conc(s) | s € Gp} as the set of all arguments we can construct from P.
For an argument c from P (c € Ap), we have that

e Conc(c) =<¢,

(ii)

Vulp(c) = {Vul(s) | s € Gp and Conc(s) = c}, and

If c is an argument, then Conc(c) is referred to as the conclusion of c, and Vulp(c)
is referred to as the vulnerabilities of c in P. When the context is clear, we will write
simply Vul(c) instead of Vul p(c).

Now we will clarify the connection between the existence of statements and the exis-
tence of a derivation in a reduct.

Lemma 1
Let P be an NEP, T = (T, F) an interpretation and Qp(Z) = (T", F") the least 3-valued
model of £. It holds

c € T" iff there exists a statement s constructed from P such that Conc(s) = c and
Vul(s) CF.

c € F” iff for every statement s constructed from P such that Conc(s) = c, we have
Vul(s) TAO

We can prove both results in Lemma [I] by induction. Assuming that wt = (T;, EF)
zz
for each i € N, we can prove the right-hand side of item|(i)]and the left-hand side of item
[(Gi)] by induction on the value of 2 after guaranteeing the following results:

e Ifc € T;, then there exists a statement s constructed from P such that Conc(s) = c
and Vul(s) C F.

e Ifc ¢ Fj, then there exists a statement s constructed from P such that Conc(s) = c
and Vul(s) NT = @.

The remaining cases of Lemma [I]can be proved by structural induction on the con-
struction of a statement s (see a detailed account of the proof of LemmafI]in Section
of[Appendix A).

Lemma [1] ensures that statements are closely related to derivations in a reduct. An
atom c is true in the least 3-valued model of £ iff we can construct a statement with
conclusion c and whose vulnerabilities are false according to Z; otherwise, c is false in
the least 3-valued model of £ iff for every statement whose conclusion is c, at least one
of its vulnerabilities is true in Z. The next result is a direct consequence of Lemma [I]

Corollary 2
Let P be an NEP.

Assume ZI = (0, HBp) and Qp(Z) = (T’,F’). It holds that c € T’ iff there exists a
statement s constructed from P such that Conc(s) = c.

There is no statement s constructed from P such that Conc(s) = c iff c € F” for every
interpretation Z with Qp(Z) = (T’, F’).

The reduct of P with respect to (0, HB p) gives us all the possible derivations of P, and
from these derivations, we can construct all the statements associated with P. On the
other hand, the atoms that are lost in the translation, i.e., the atoms not associated with


On the Equivalence between Logic Programming and SETAF 11

statements are simply those that are false in the least 3-valued model of every possible
reduct of P. Besides establishing connections between statements and derivations in a
reduct, Lemmaf[I]also plays a central role in the proof of Theorems [4] and 5]

Apart from that, intuitively, we can see a statement as a tree-like structure representing
a possible derivation of an atom from the rules of a program. In contrast, an argument for
c in P is associated with the (derivable) atom c itself and can be obtained by collecting
all the statements with the same conclusion c (i.e., all the possible ways of deriving c in

Example 3

Consider the NEP P below with rules {r1,..., 7g}:
Tr: @ rg: bea 73: C<-notc
rg: d<b,not a,notd r5: d¢notc,notd re: e<b,c,note
r7: ce f,notg ra: frag

According to Definition [8] we can construct the following statements from P:

81: a 82: be (s1) 83: c¢-notc
4: d<(S2),not a,not d s5: d<¢<-notc,notd 86: e< (82), (53), not e

In the next table, we give the conclusions and vulnerabilities of each statement:
| Sq] $2 $3 S4 S5 S6
Conc(.)| a 0b c d d e€
vul(.)}] 0 0 {ec} {a,d} {e,d} {e,e}

Alternatively, we can depict statements as possible derivations as in Fig. [2}

[si] a [s2] bea [sa] c#-notc
|
a
[sa] d<¢ b,not a,not d [s5] d< not c,not d [se] e < b,c,not e
| SoN
bea bia ct notec
|
a a

Fig. 2: Statements constructed from P

The vulnerabilities of a statement s are associated with the negative literals found in
the derivation of s. If not a is one of them, we know that a is one of its vulnerabilities.
This means that if a is derived, then Conc(s) cannot be obtained via this derivation
represented by s. However, it can still be obtained via other derivations/statements. For
instance, in the program P of Example B] the derivation of a suffices to prevent the
derivation of d via statement s4 (for that reason, a € Vul(s4)), but we still can derive d
via s5. Notice also that there are no statements with conclusions f and g. From Corollary


12 J. Alcantara, R. Cordeiro and S. Sd

O—-@e

Fig. 3: A SETAF Ap = (Ap, Attp)

[2] we know that it is not possible to derive them in P as they are false in the least 3-valued
model of each reduct of P. In addition, to determine the vulnerabilities of an atom (and
not only of a specific derivation leading to this atom), we collect these data about the
statements with the same conclusions to give the conclusions and vulnerabilities of each
argument. In our example, we obtain the following results:

| a b Cc d e€

Conc(.)| a b c d e€
vul(.) | {0} {0} fet {lad}, {ed}} {{e,e}}

As the vulnerabilities of an atom/argument a are a collection of the vulnerabilities of
the statements whose conclusion is a, any set containing at least one atom in each of
these statements suffices to prevent the derivation of a in P. In our example, there are
two statements with the same conclusion d and Vul(d) = {{a,d}, {c, d}}. Thus any set
of atoms containing {d} or {a,c} prevents the conclusion of d in P. We will resort to
these minimal sets to determine the attack relation:

Definition 9
Let P be an NEP and let B and a be respectively a set of arguments and an argument

in the sense of Definition B] We say that (B,a) € Attp iff B is a minimal set (w.r.t. set
inclusion) such that for each V € Vulp(a), there exists be BOV.

For the arguments of Example B] it holds that both a and 6 are not attacked, c at-
tacks itself, c attacks e, e attacks itself, d attacks itself, a and c (collectively) attack d.
This strategy of extracting statements from NZPs rules and then gathering those with
identical conclusions into arguments is not novel; in ees TT the authors
bout les a translation from NZPs into Abstract Dialectical Frameworks Hote anthon

01

Brewka and Woltran||2010) by following a similar path. Using the thus-defined

notions of arguments and attacks, we define the SETAF associated with an NLP.

Definition 10

Let P be an NLP. We define its associated SETAF as Up = (Ap, Attp), where Ap is
the set of arguments in the sense of Definition [8] and Attp is the attack relation in the
sense of Definition [9]

As an example, the SETAF Ap = (Ap, Aitp) associated with the NLP of Example]
is depicted in Fig.


On the Equivalence between Logic Programming and SETAF 13

3.2 Equivalence Results

Once the SETAF has been constructed, we show the equivalence between the semantics
for an NEP P and their counterpart for the associated SETAF Ap. One distinguishing
characteristic of our approach in comparison with Konig et al.’s proposal
is that it is more organic. We prove the equivalence results by identifying con-
nections between fundamental notions used in the definition of the semantics for NI Ps
and SETAFs. With this purpose, we introduce two functions: £2Zp associates an inter-
pretation to each labelling while Z2£p associates a labelling to each interpretation. We
then investigate the conditions under which they are each other’s inverse and employ

these results to prove the equivalence between the semantics. These functions essentially
permit us to treat interpretations and labellings interchangeably.

Definition 11 (L2Tp and T2£Lp Functions)

Let P be an NLP, Xp = (Ap, Attp) be its associated SETAF, Tnt be the set of all the
3-valued interpretations of P and Lab be the set of all labellings of 2l,. We introduce a
function £2TZp : Lab > Tnt such that £L2Tp(L) = (T, F), in which

e T={c¢ HBp|ce€ Ap and L(c) = in};
e F={ce€ HBp|c¢ Ap orc€e Ap and L(c) = out};

TUF ={cée HBp|cé Ap and L(c) = undec}.

We introduce a function Z2£p : Int + Lab such that for any J = (T, F) € TInt and
any c € Ap,

T2Lp(L)(c) =inif ce T;
T2Lp(Z)(c) = out ifce F;
T2£Lp(L)(c) =undec ifc ¢TUF.

T2£p(L)(c) is not defined if c ¢ Ap.

The correspondence between labellings and interpretations is clear for those atoms
c € HBp inwhichc € Ap. In this case, we have that c is interpreted as true iff c is labelled
as in; c is interpreted as false iff c is labelled as out. In contradistinction, those atoms
c € HBp not associated with arguments (c ¢ Ap) are simply interpreted as false. This
will suffice to guarantee our results; next theorem assures us that T2£p(L2Tp(L)) = L:

Theorem 8
Let P be an NEP and Ap = (Ap, Attp) be the associated SETAF. For any labelling L
of Up, it holds Z2Lp(L2Lp(L)) = CL.

In general, £2Tp(Z2L£ p(T)) is not equal to Z, because of those atoms c occurring in an
NLP P, but not in Ap. However, when M is a partial stable model, £2Tp(Z2£ p(M)) =
M:

Theorem 4
Let P be an NEP, Ip = (Ap, Attp) be the associated SETAF and M = (T,F) bea
partial stable model of P. It holds that L2Tp(Z2Lp(M)) = M.

This means that when restricted to partial stable models and complete labellings,
L2Tp and £2Lp are each other’s inverse. From Lemmaf[i] and Theorems[3]and [4] we can
obtain the following result:


Pe wnNm re e

Be wn re

14 J. Alcantara, R. Cordeiro and S. Sd
Theorem 5
Let P be an NEP and Ap = (Ap, Attp) be the associated SETAF. It holds

£ is a complete labelling of Ap iff £2Zp(L) is a partial stable model of P.
M is a partial stable model of P iff Z2£p(M) is a complete labelling of Ap.

Theorem §] is one of the main results of this paper. It plays a central role in ensuring
the equivalence between the semantics for NZP and their counterpart for SETAF:

Theorem 6
Let P be an NEP and Ip = (Ap, Attp) be the associated SETAF. It holds

. £ is a grounded labelling of 2p iff £L2Zp(L) is a well-founded model of P.
. £ is a preferred labelling of 2p iff £L2Tp(L) is a regular model of P.

. Lis astable labelling of Ap iff L2Zp(L) is a stable model of P.

. £ is a semi-stable labelling of Ap iff £L2Zp(L) is an L-stable model of P.

The following result is a direct consequence of Theorems [4] and [6}

Corollary 7
Let P be an NEP and Ap = (Ap, Attp) be the associated SETAF. It holds

. M is a well-founded model of P iff Z2£p(M) is a grounded labelling of Ap.
. M is a regular model of P iff Z2£p(M) is a preferred labelling of Ap.

. M is a stable model of P iff Z2£p(M) is a stable labelling of Ap.

. M is an L-stable model of P iff Z2£p(M) is a semi-stable labelling of Ap.

Next, we consider the NEP exploited by Caminada et al. (Caminada et_al./2015b) as

a counterexample to show that in general, L-stable models and semi-stable labellings do
not coincide with each other in their translation from NIPs to AAFs:

Example 4
Let P be the NEP and Ap be the associated SETAF depicted in Fig. J

© e©)

d<«notd c+ not c,not d
a not b b< not a
c+ not c,not a e+ not e,not b
(a) P (b) Ap

Fig. 4: NLP P and its associated SETAF Ap

As expected from Theorems[5]and[6] we obtain in Table[I]the equivalence between par-
tial stable models and complete labellings, well-founded models and grounded labellings,
regular models and preferred labellings, stable models and stable labellings, D-stable
models and semi-stable labellings. We emphasise the coincidence between L-stable mod-

els and semi-stable labellings in Table[IJas it does not occur in (Caminada et: al.|2015b).

In that reference, the associated AAF’ possesses two semi-stable labellings in contrast


On the Equivalence between Logic Programming and SETAF 15

with the unique L-stable model M3 of P. In the next two sections, we will show that
this relation between NEPs and SETAFs has even deeper implications.

Table 1: Semantics for P and 2p

Partial Stable Models M2 = ({a}, {b}) Complete Labellings £2 = ({a}, {b}, {c, d,e})
M3 = ({b}, {a,e}) Ls = ({b}, {a,e}, {e, d})
Well-Founded Models Mz = (0,0) Grounded Labellings £1 = (0,0, {a, b,c, d, e})
Ma = ({a}, {b}) Lo = ({a}, {b}, {e, d, e})
Regular Models Na = BA aga Preferred Labellings Es = (6, tas slot dH
Stable Models None Stable Labellings None
Semi-stable
L-stable Models Ms3 = ({b}, {a, e}) L3 = ({b}, {a,e}, {c, d})

Labellings

4 From SETAF to NLP

Now we will provide a translation in the other direction, i.e., from SETAFs to NLPs. As
in the previous section, this translation guarantees the equivalence between the semantics
for NEPs and their counterpart for SETA Fs.

Definition 12
Let 2 = (A, Att) be a SETAF. For any argument a € A, we will assume V, = {V |

V is a minimal set (w.r.t. set inclusion) such that for each B € Att(a), there exists b €
BV}. We define the associated NEP Py as follows:

Py = {a not bi,...not b, |aEeA,V €V, and V = {br,...,bn}}.
Example 5

Recall the SETAF & of Example[I] (it is the same as that in Fig/4b). The associated NLP
Px is

d<notd c+ not c,not d
a<not b b< nota
c<not c,not a e+ not e,not b

Notice that Py and the NEP P of Example [4] are the same. As it will be clear in
the next section, this is not merely a coincidence. Besides, from Definition [L2} it is clear
that HBp, = A. Consequently, when considering a SETAF Y and its associated NLP
Py, the definition of the function £L2TZy (resp. Z2£y), which associates labellings with
interpretations (resp. interpretations with labellings), will be simpler than the definition
of £L2Tp (resp. Z2£p) presented in the previous section.


16 J. Alcantara, R. Cordeiro and S. Sd

Definition 13 (L2Ty and T2Ly Functions)
Let 2 be a SETAF and P be its associated NLP, Lab be the set of all labellings of 2l
and Znt be the set of all the 3-valued interpretations of Py. We introduce the functions

L2Ty : Lab > Ent, in which
L2Ty(L) = (in(L), out(L)) .

Obviously in(L) U out(L) = undec(L).
T2Ly : Int > Lab, in which for M = (T, F) € Int,

T2Ly(M) = (T, F, TUF).

In contrast with £2Tp and T2£p, the functions L2Zy and T2£y are each other’s
inverse in the general case:

Theorem &
Let 2 = (A, Att) be a SETAF and Py its associated NLP.

e For any labelling £ of 2, it holds T2La(L2Tq(L)) = L.

rPwWn re e

Pe wn re

For any interpretation Z of Py, it holds £L2Ty(Z2£y(Z)) = T.
A similar result to Theorem [5] also holds here:

Theorem 9
Let 2 be a SETAF and Py be its associated NLP. It holds

£ is a complete labelling of 2 iff £2Zq(L) is a partial stable model of Py.
M is a partial stable model of Py iff T2L£4(M) is a complete labelling of 2.

From Theorem [9] we can ensure the equivalence between the semantics for NEP and
their counterpart for SETAF:

Theorem 10
Let 2 be a SETAF and Py its associated NEP. It holds

. £ is a grounded labelling of 2 iff £2Zy(L) is a well-founded model of Py.
. Lis a preferred labelling of 2 iff L2Zy(L) is a regular model of Py.

. Lis a stable labelling of 2 iff L2Zy(L) is a stable model of Py.

. £ is a semi-stable labelling of 2 iff £2Zq(L) is an L-stable model of Py.

The following result is a direct consequence of Theorems [8] and [10]

Corollary 11
Let 2 be a SETAF and Px its associated NLP. It holds

. M is a well-founded model of Py iff Z2£y(M) is a grounded labelling of 2.
. M is a regular model of Py iff Z2Lq(M) is a preferred labelling of 2.

. Misa stable model of Py iff T2£y(M) is a stable labelling of 2.

. M is an L-stable model of Py iff Z2Lq(M) is a semi-stable labelling of 2.

Recalling the SETAF & and its associated Py of Example [5] we obtain the expected
equivalence results related to their semantics (see Table [I]. In the next section, we will
identify a class of NEPs in which the translation from a SETAF to an NIP (Definition
behaves as the inverse of the translation from an NLP to a SETAF (Definition 110).


On the Equivalence between Logic Programming and SETAF 17

5 On the relation between RFALPs and SETAFs

We will recall a particular kind of NIPs, called Redundancy-Free Atomic Logic Programs
(RFALPs). From an RFALP P, we obtain its associated SETAF Ap via Definition [iO]
from 2p, we obtain its associated NLP Py, via Definition [[2] By following the other
direction, from a SETA F 2, we obtain its associated NEP Py, and from Py, its associated
SETAF Ap,. An important result mentioned in this section is that P = Py, and 2 =
Ap,, ie., the translation from an NLP to a SETAF and the translation from a SETAF
to an NIP are each other’s inverse. Next, we define RFALPs:

Definition 14 (RFALP )

We define a Redundancy-Free Atomic Logic Program (RFALP) P as an NIP such that

. P is redundancy-free, ie., HBp = {head(r) | r € P} and if c + not bj,..., not bp € P,
there is no rule c + not cj,...,not Cn: € P such that {c1,...,¢n/} C {bi,..., On}.
. P is atomic, i.e., each rule has the form c + not bi,...,not by, (n > 0).

Firstly, Proposition sustains that for any SETAF , its associated NEP Py will
always be an RFALP:

Proposition 12
Let 2 = (A, Att) be a SETAF and Py its associated NLP. It holds Py is an RFALP.

The following results guarantee that 2 = %p, (Theorem [I3) and P = Py, (Theorem
(14):
Theorem 13

Let 2 = (A, Att) be a SETAF, Py its associated NEP and 2p, the associated SETAF
of Py. It holds that 20 = 2p, .

Theorem 14
Let P be an RFALP, Ap its associated SETAF and Py, the associated NEP of Ap. It
holds that P = Py,.

Remark 1

Minimality is crucial to ensure that the translation from an NLP to a SETAF and
the translation from a SETAF to an NLP are each other’s inverse. If the minimality
requirement in Definition[I](and consequently in Definition[9) were dropped, any SETAF
(among other combinations) in Fig. [5]could be a possible candidate to be the associated
SETAF Ap of the RFALP P

c< not a,not c c+ not b,not c
a b

As aresult, Theorem[I3]would no longer hold, and these translations would not be each
other’s inverse. Notice also that the SETA Fs in Fig. ]have the same complete labellings
as non-minimal attacks are irrelevant and can be ignored when determining semantics
based on complete labellings.

Theorems [13] and [14] reveal that SETAFs and RFALPs are essentially the same for-
malism. The equivalence between them involves their semantics and is also structural:


18 J. Alcantara, R. Cordeiro and S. Sd

©
—— ©) OQ © ©)

(a) Mp (b) wy (c) wy

)
Fig. 5: Possible SETAFS associated with P

two distinct SETAFs will always be translated into two distinct RFALPs and vice
versa. In contradistinction, Theorem would not hold if we had replaced our trans-
lation from NEP to SETAF (Definition with that from NIP to AAF presented in
(Caminada et all[2015b). Thus, the connection between NIPs and SETAFs is more ro-
bust than that between NEPs and AAFs. In the forthcoming section, we will explore
how expressive RFALPs can be; we will ensure they are as expressive as NPs.

6 On the Expressiveness of RFALPs

Dvorak et al. comprehensively characterised the expressiveness of SETA Fs
(2019). Now we compare the expressiveness of NI Ps with that of RFALPs. In the previous
section, we established that SETAFs and RFALPs are essentially the same formalism.
We demonstrated that from the SETAF 2p associated with an NLP P, we can obtain
P; and conversely, from the NUP Py associated with a SETAF 2, we can obtain 2. Here,
we reveal that this connection between SETAFs and RFALPs is even more substantial:
RFALPs are as expressive as NIZPs when considering the semantics for NLPs we have
exploited in this paper. With this aim in mind, we transform any NEP P into an RFALP
P* by resorting to a specific combination (denoted by H+ yrpy) of some program trans-

1997 1999). Although each
program transformation in + yrpy was proposed in (Brass and Dix remem
the combination of these program transformations (as far as we know) has not been in-
vestigated yet. Then, we show that P and P* share the same partial stable models. Since
well-founded models, regular models, stable models, and L-stable models are all settled
on partial stable models, it follows that both P and P* also coincide under these seman-
tics. Based on Dunne et al.’s work (Dunne et al[2015), where they define the notion of
expressiveness of the semantics for AAF’s, we define formally expressiveness in terms of
the signatures of the semantics for NIPs:

formations proposed by Brass and Dix (

Definition 15 (Expressiveness)
Let P be a class of NLPs. The signature OF), of the partial stable models associated
with P is defined as

Ups = {o(P)| PP},
where o(P) = {Z |Z is a partial stable model of P} is the set of all partial stable models
of P.


On the Equivalence between Logic Programming and SETAF 19

Given two classes P; and P2 of NIPs, we say that P; and P2 have the same expres-
siveness for the partial stable models semantics if Hay = ar

In other words, P; and P2 have the same expressiveness if

e For every P, € P, there exists P, € P2 such that P; and P, have the same set of
partial stable models.

e For every P2 € P2, there exists P, € P; such that P; and P2 have the same set of
partial stable models.

Similarly, we can define when P, and P2 have the same expressiveness for the well-
founded, regular, stable, and L-stable semantics.

As the class of RFALPs is contained in the class of all NLPs, to show that these classes
have the same expressiveness for these semantics, it suffices to prove that for every NDP,
there exists an RFALP with the same set of partial stable models. We will obtain this
result by resorting to a combination of program transformations:

Definition 16 (Program Transformation 1994;\1997; ))

A program transformation is any binary relation +> between NLPs. By +>* we mean the
reflexive and transitive closure of KH.

Thus, P +3* P’ means that there is a finite sequence P = P; +> --- > P, = P’. We
are particularly interested in program transformations preserving partial stable models:

Definition 17 (Equivalence Transformation 1994; |1997; 1999))

We say a program transformation + is a partial stable model equivalence transformation
if for any NEPs P, and P2 with P, > Py», it holds M is a partial stable model of P, iff
M is a partial stable model of P).

From Definitions [18] to [21) we focus on the following program transformations intro-
duced in 1999): Unfolding (it is also known as Generalised
Principle of Partial Evaluation (GPPE)), Elimination of Tautologies, Positive Reduction,
and Elimination of Non-Minimal Rules. They are sufficient for our purposes.

Definition 18 (Unfolding (Brass and Didl1994; (199%; (1999))

An NEP Py results from an NEP P, by unfolding (P,; yp P2) iff there exists a rule

C# 4,41,...,Am,not b1,...,not b, € P, such that
Pp = (P, — {cH a,a4,...,dm, not b1,..., not b,})
WI yy » non y Wp gs ws j Gig BOE bi,.--;not bi, not bi,...,not by, |
ae Gq, +++, Gp, not Dig nn op MOE bi, e Pi}.

Definition 19 (Elimination of Tautologies 1994; 1997; '1999))
An NIP P, results from an NLP P, by elimination of tautologies (P,; +7 P») iff there
exists a rule r € P, such that head(r) € bodyt(r) and P) = P, — {r}.

Definition 20 (Positive Reduction 1994; '1999))


20 J. Alcdntara, R. Cordeiro and S. Sé
An NEP Py results from an NEP P, by positive reduction (P, +p P2) iff there exists a
rule c+ Qj,...,@m,not b,not b),...,not by, € P; such that b ¢Z {head(r) | r € P,} and

Pp = (Pi — {cH a,...,am,not b,not bi,...,not b,})

Uf{ee ay,...,@m,not b1,...,not by}.

Definition 21 (Elimination of Non-Minimal Rules 1994; '1994))

An NIP P, results from an NIP P, by elimination of non-minimal rules (Py jy, P2)
iff there are two distinct rules r and r’ in P, such that head(r) = head(r’), body* (r’) C
body (r), body~(r’) C body~ (r) and Py = P, — {r}.

Now we combine these program transformations and define + yrpy as follows:

Definition 22 (Combined Transformation)
Let Bb urpmM=Hu Ubr Up UH y.

We call an NLP P irreducible concerning +> if there is no NEP P’ 4 P with P* P’.
Besides, we say +> is strongly terminating iff every sequence of successive applications

of ++ eventually leads to an irreducible NEP. As displayed in (Brass and Dix , not

every program transformation is strongly terminating. For instance, in the NZP

«+ Ob
- a
<— a,notc

aaemsa

if we apply unfolding (+ y) to the third rule, this rule is replaced by c + b, not c. We can
now apply unfolding again to this rule and get the original program; such an oscillation
can repeat indefinitely. Thus we have a sequence of program transformations that do not
terminate. However, if we restrict ourselves to fair sequences of program transformations,
the termination is guaranteed:

Definition 23 (Fair Sequences 1998))

A sequence of program transformations P, > ---+> P,, is fair with respect to 4 if

Every positive body atom occurring in P; is eventually removed in some P; with 1 <i<n
(either by removing the whole rule using a suitable program transformation or by an
application of +y);

Every rule r € P; such that head(r) € body*(r) is eventually removed in some P; with
i<j <n (either by applying +r or another suitable program transformation).

The sequence above of program transformations is not fair, because it does not remove
the positive body atoms occurring in the program. In contrast, the sequence of program
transformations given by

a << 5b a¢a
b + a
b + a b + a b+ a
ru Hp Cc + a,notc Hy ru €
c < a,notc c + a,notc a c
c c

is not only fair but also terminates. The next result guarantees that it is not simply a
coincidence:


On the Equivalence between Logic Programming and SETAF 21

Theorem 15
The relation + yrpy is strongly terminating for fair sequences of program transforma-
tions, i.e., such fair sequences always lead to irreducible programs.

Theorem |1L5}is crucial to obtain the following result:

Theorem 16
For any NLP P, there exists an irreducible NLP P* such that P+>7ppyy P*.

This means that from an NLP P, it is always possible to obtain an irreducible NEP
P* after successive applications of ++ yrpm. Indeed, P* is an RFALP:

Theorem 17

Let P be an NEP and P* be an NEP obtained after applying repeatedly the program
transformation ++yrpy until no further transformation is possible, i.e., P +7ppjy P*
and P* is irreducible. Then P* is an RFALP.

From Theorems [15] and [I7] we can infer that for fair sequences, after applying repeat-
edly + urpm, we will eventually produce an RFALP. In fact, every RFALP is irreducible:

Theorem 18
Let P be an RFALP. Then P is irreducible with respect to 6 yrpy.

Theorems [I6] and [17] guarantee that every NEP P can be transformed into an RFALP
P* by applying + yrpy a finite number of times. It remains to show that P and P* share
the same partial stable models (and consequently, the same well-founded, regular, stable,
and L-stable models). Before, however, note that > yrpy does not introduce new atoms;
instead, it can eliminate the occurrence of existing atoms in an NIP. For simplicity in
notation, we assume throughout the rest of this section that HBp = HBp, whenever
P Uppy P’. Next, we recall that these program transformations preserve the least
models of positive programs:

Lemma 19 ((Brass and Did|1994;|1997))

Let P, and P» be positive programs such that P, >, Po, in which x € {U,T, P, M}. It
holds M is the least model of P; iff M is the least model of P.

In the sequel, we aim to extend Lemma[I9]to NLPs. Notice, however, that we already
have the result for the program transformation ty:

Theorem 20 ((Aravindan and Minh|1995))
Let P, and P,; be NEPs such that P, +y Py . It holds M is a partial stable model of P;
iff M is a partial stable model of Po.

It remains to guarantee the result for the program transformation +7, +p and KH yy:

Theorem 21
Let P, and P; be NEPs such that Py +7 Pp». It holds M is a partial stable model of P;
iff M is a partial stable model of Pp.

Theorem 22
Let P, and P, be NEPs such that P, +p Py». It holds M is a partial stable model of P;
iff M is a partial stable model of Pp.


22 J. Alcdntara, R. Cordeiro and S. Sé

Theorem 28
Let P, and P, be NDPs such that P, yy P2. It holds M is a partial stable model of P,
iff M is a partial stable model of Pp.

Consequently, if Pi 4+ urpy P2, then P; and P2 share the same partial stable models.
By repeatedly resorting to this result, we can even show that for any NLP, there exists an
irreducible NEP with the same set of partial stable models, well-founded models, regular
models, stable models, and L-stable models:

Theorem 24
Let P be an NEP and P* be an irreducible NEP such that P -7,ppy, P*. It holds M is
a partial stable model of P iff M is a partial stable model of P*.

Corollary 25

Let P be an NEP and P* be an irreducible NEP such that P O7,ppyy P*. It holds M is
a well-founded, regular, stable, D-stable model of P iff M is respectively a well-founded,
regular, stable, L-stable model of P*.

As any irreducible NEP is an RFALP (Theorem[L%), the following result is immediate:

Corollary 26

For any NLP P, there exists an RFALP P* such that M is a partial stable, well-founded,
regular, stable, L-stable model of P iff M is respectively a partial stable, well-founded,
regular, stable, L-stable model of P*.

Given that each NEP can be associated with an RFALP preserving the semantics above,
it follows that NEP and RFALPs have the same expressiveness for those semantics:

Theorem 27
NLIPs and RFALPs have the same expressiveness for partial stable, well-founded, regular,
stable, and L-stable semantics.

Another important result is that the SETAF corresponding to an NDP is invariant
with respect to H yrpm:

Theorem 28
For any NLIPs Py and Pp, if Py ->+UTPM Po, then Ap, = Ap,

This means that any NEP in a sequence of program transformations from +> yrpy has
the same corresponding SETAF’. For instance, every NEP in this sequence

a < 6b a¢a
bo“ a
b+ a yy Fe @ ie @ & aaohe ee 8 ™ ete
no
c £ a,notc Gee a,not c to , Ui e¢ v
Cc Cc

leads to the same corresponding SETAF, constituted by a unique (unattacked) argument:

©

Theorem also suggests an alternative way to find the SETAF corresponding to
an NIP P: instead of resorting directly to Definition [8] to construct the arguments,
we can apply (starting from P) +yrpm successively by following a fair sequence of


On the Equivalence between Logic Programming and SETAF 23

program transformations. By Theorems[[5]and[I7] we know that eventually, we will reach
an RFALP whose corresponding SETAF is identical to that of the original program P
(Theorem 28). Then, we apply Definition 8]to this RFALP to obtain the arguments and
Definition 9] for the attack relation. Notably, when P is an RFALP, Definition [8] becomes
considerably simpler, requiring only its first item to characterise the statements.

In addition, from the same NIP, various fair sequences of program transformations
can be conceived. Recalling the NIP

«+ Ob
- a
<- a,not c

aa Se 8

exploited above, we can design the following alternative fair sequence

a < 0b
a¢ea a < 0b
bea Hy b H& any b H& bo *@ © OY,
Cc
c & a,notce - T ¢ ue
c c c

This sequence produced the same RFALP as before; it is not a coincidence. Apart from
being strongly terminating for fair sequences of program transformations, the relation
++urpm has an appealing property; it is also confluent:

Theorem 29
The relation ++ yrpwm is confluent, i.e., for any NUPs P, P’ and P”, if Py ppyy P’ and
PS tUrpm P" and both P’ and P” are irreducible, then P’ = P”.

By confluent + yrpy, we mean that it does not matter the path we take by repeatedly
applying + yrpw, if it ends, it will always lead to the same irreducible NEP. In addition,
as any irreducible NEP is an RFALP (Theorem [I%), and the translations from SETAF
to RFALPs and conversely, from RFALPs to SETAF are each other’s inverse (Theorems
[13] and [14), we obtain that two distinct SETAFs will always be associated with two
distinct NEPs. The confluence of + yrpy is of particular significance from the logic
programming perspective as it guarantees that the ordering of the transformations in
UTPM does not matter: we are free to choose always the “best” transformation, which
maximally reduces the program. Consequently, TheoremP9]also sheds light on the search
for efficient implementations in NDPs.

From the previous section, we know that the equivalence between SETA Fs and RFALPs
is not only of a semantic nature but also structural: two distinct SETAFs will always be
translated into two distinct RFALPs and vice versa. Now we enhance our understanding
of this result still more by establishing that

e RFALPs are as expressive as NIPs.

e The SETAF corresponding to an NEP is invariant with respect to 4 urpm, i-e., if
Pi +urpm Pp», then Ap, = A p,.

e Each NLP P leads to a unique RFALP P* via the relation + urpm. Besides, P and
P* have the same partial stable, grounded, regular, stable, and L-stable models.

Beyond revealing the connections between SETA Fs and NIPs, the results in this paper
also enhance our understanding of NZPs themselves. To give a concrete example, let us


24 J. Alcantara, R. Cordeiro and S. Sd

consider the following issue: in the sequence of program transformations in H yrpm,
atoms can be removed. Are these atoms underivable and set to false in the partial stable
models of the program or true/undecided atoms can be removed in this sequence? Such
questions can be answered by considering some results from Section B] and the current
section. In more formal terms, let P and P* be NLPs such that P 47,7p,, P* and P* is
irreducible. We have

e P* is an RFALP (Theorem [17), and the set of atoms occurring in P* is
{head(r) |r € P*} (Definition [L4);

e Ap» = {head(r) |r € P*} is the set of all arguments we can construct from P*
(Definition [8), and Xp = Ap« (Theorem 8), i.e., Ap = Ap;

e Thus c occurs in P, but does not occur in P* iff there is no statement s con-
structed from P such that Conc(s) = c. According to Corollary] c € F’ for every
interpretation Z with Qp(Z) = (T’, F’).

Consequently, every atom occurring in P, but not occurring in P* is set to false in the
least 3-valued model of each disjunct of P. In particular, they will be false in its partial
stable models.

Supported by the findings presented in the current section, we can argue that SETA Fs
and RFALPs are essentially the same paradigm, and both are deeply connected with
NIPs.

7 Conclusion and Future Works

This paper investigates the connections between frameworks with sets of attacking ar-
guments (SETAFs) and Normal Logic Programs (NEPs). Building on the research in
2021) we employ the characterisation of the
SETAF semantics in terms of labellings (Flouris and Bikakis to establish a map-
ping from NLPs to SETAFs (and vice versa). We further demonstrate the equivalence
between partial stable, well-founded, regular, stable, and L-stable models semantics for
NIPs and respectively complete, grounded, preferred, stable, and semi-stable labellings
for SETAFs.

Our translation from NIPs to SETAFs offers a key advantage over the translation
from NLPs to AAFs presented in ICominada et allloousth. Our approach captures the
equivalence between semi-stable labellings for SETA Fs and L-stable models for NZPs. In
addition, their translation is unable to preserve the structure of the NEPs. While an NIP
can be translated to an AAF, recovering the original NZP from the corresponding AAF
is generally not possible. In contradistinction, we have revisited a class of NEPs called
Redundancy-Free Atomic Logic Programs (RFALPs). For RFALPs, the translations from
NLPs to SETAFs, and from SETAF’s to NI Ps also preserve their structures as they are
each other’s inverse. Hence, when compared to the relationship between NZPs and AAF's,
the relationship between NLPs and SETAFs is demonstrably more robust. It extends
beyond semantics to encompass structural aspects.

Some of these results are not new as they have already been obtained independently in
(Konig et_al][2029). In fact, their translation from NLPs to SETAFs and vice versa co-
incide with ours, and the structural equivalence between RFALPs and SETAFS has also
been identified there. Notwithstanding, our proofs of these results stem from a signifi-


On the Equivalence between Logic Programming and SETAF 25

cantly distinct path as they are based on properties of argument labellings and are deepl
rooted in works such as (Caminada et_al/2015 bs Alcantara and Sa

2021). For instance, our equivalence results are settled on two important aspects:

e Properties involving the maximisation/minimisation of labellings adapted from
2015b) to deal with labellings for SETAFs.
Caminada et al |2015b), we proposed a mapping from inter-

pretations to labellings and a mapping from labellings to interpretations. We also
showed that they are each other’s inverse.

In contrast, in (Konig et al. the equivalence between the semantics is demon-

strated in terms of extensions. They also have not tackled the controversy between semi-
stable and L-stable, one of our leading motivations for developing this work.

In addition to showing this structural equivalence between RFALPs and SETAFs, we
have also investigated the expressiveness of RFALPs. To demonstrate that they are as
expressive as NL Ps, we proved that any NLP can be transformed into an RFALP with the
same partial stable models through repeated applications of the program transformation
4+urpm. It is worth noticing that + yrpy_results from the combination of the follow-
ing program transformations presented in 1999): unfolding,
elimination of tautologies, positive reduction, and elimination of non-minimal rules. In
the course of our investigations, we also have obtained relevant findings as follows:

e Again inspired in (

e RFALPs are irreducible with respect to +yrpm: the application of + yrpy to an
RFALP will result in the same program.

e The mapping from NIPs to SETAFs is invariant with respect to the program
transformation + yrpy, i.e., if an NEP Py is obtained from an NEP P, viat+yurpm,
then the SETAF corresponding to P; is the same corresponding to P».

e The program transformation > yrpy is confluent: any NEP will lead to a unique
RFALP after repeatedly applying +> yrpy. Consequently, two distinct RFALPs will
always be associated with two distinct NDPs.

In summary, RFALPs (which are as expressive as NLPs) and SETAFSs are essentially
the same formalism. Roughly speaking, we can consider a SETAF as a graphical rep-
resentation of an RFALP, and an RFALP as a rule-based representation of a SETAF.
Any change in one formalism is mirrored by a corresponding change in the other. Thus,
SETAFs emerge as a natural candidate for representing argumentation frameworks cor-
responding to NIPs.

Regarding the significance and potential impact of our results, we highlight that by pur-
suing this line of research, one gains insight into what forms of non-monotonic reasoning
can and cannot be represented by formal argumentation. In particular, by enlightening
these connections between SETAFs and NIPs, many approaches, semantics and tech-
niques naturally developed for the former may be applied to the latter, and vice versa.
While SETAFs serve as an inspiration for defining RFALPs, the representation of NDPs
as SETAFs is an alternative for intuitively visualising logic programs.

In addition, our results associated with the confluence of +>yrpy are of particular
significance from the logic programming perspective as they guarantee that the ordering
of the transformations in + yrpy does not matter: we are free to choose always the


26 J. Alcdntara, R. Cordeiro and S. Sé

“best” transformation, which maximally reduces the program. Consequently, our paper
also sheds light on the search for efficient implementations in ND Ps.

Natural ramifications of this work include an in-depth analysis of other program trans-
formations beyond those studied here and their impact on SETAF and argumentation in
general. Given the close relationship between Argumentation and Logic Programming,
a possible line of research is to investigate how Argumentation can benefit from these
program transformations in the development of more efficient algorithms. The structural
connection involving RFALPs and SETAFS gives rise to exploiting other extensions of
Dung AAF’s; in particular, we are interested in identifying which of them are robust
enough to preserve the structure of logic programs. Along this same line of research, it
is also our aim to study connections between extensions of NI Ps (including their para-
consistent semantics) and Argumentation.

Competing interests: The authors declare none.

References

ALCANTARA, J. AND SA, S. 2021. Equivalence results between SETAF and attacking abstract
dialectical. frameworks. In Proceedings NMR, pp. 139-48.

ALCANTARA, J., SA, S., AND ACOSTA-GUADARRAMA, J. 2019. On the equivalence between ab-
stract dialectical frameworks and logic programs. Theory and Practice of Logic Programming,
19, 5-6, 941-956.

ARAVINDAN, C. AND MINH, D. P. 1995. On the correctness of unfold/fold transformation of
normal and extended logic programs. The Journal of Logic Programming, 24, 3, 201-217.
BEIRLAEN, M., HEYNINCK, J., PARDO, P., AND STRASSER, C. 2018. Argument strength in

formal argumentation. FLAP, 5, 3, 629-676.

BONDARENKO, A., DuNG, P. M., Kowatski, R. A., AND Toni, F. 1997. An abstract,
argumentation-theoretic approach to default reasoning. Art. Intelligence, 93, 1-2, 63-101.
Brass, S. AND Dix, J. 1994 A disjunctive semantics based on unfolding and bottom-up evalu-
ation. In Innovationen bei Rechen-und Kommuntkationssystemen (IF IP-Congress, Workshop
FG2: Disjunctive Logic Programming and Disjunctive Databases), pp. 83-91. Springer Berlin

Heidelberg.

Brass, S. AND Dix, J. 1995. Disjunctive semantics based upon partial and bottom-up evalua-
tion. In ICLP, pp. 199-218.

Brass, S. AND Dix, J. 1997. Characterizations of the disjunctive stable semantics by partial
evaluation. The Journal of Logic Programming, 32, 3, 207-228.

Brass, S. AND Dix, J. 1998. Characterizations of the disjunctive well-founded semantics: con-
fluent calculi and iterated gcwa. Journal of automated reasoning, 20, 143-165.

Brass, S. AND Dix, J. 1999. Semantics of (disjunctive) logic programs based on partial evalu-
ation. The Journal of Logic Programming, 40, 1, 1-46.

BREWKA, G., ELLMAUTHALER, S., STRASS, H., WALLNER, J. P., AND WOLTRAN, S. 2013.
Abstract dialectical frameworks revisited. In Proceedings of the Twenty-Third international
joint conference on Artificial Intelligence, pp. 803-809.

BREWKA, G. AND WOLTRAN, S. 2010. Abstract dialectical frameworks. In Proceedings of the
Twelfth International Conference on Principles of Knowledge Representation and Reasoning,
pp. 102-111.

CAMINADA, M. 2006. Semi-stable semantics. 1st International Conference on Computational
Models of Argument (COMMA), 144, 121-130.


On the Equivalence between Logic Programming and SETAF 27

CAMINADA, M. AND AmGoupD, L. 2005. An axiomatic account of formal argumentation. In
AAAI, volume 6, pp. 608-613.

CAMINADA, M. AND AMGOUD, L. 2007. On the evaluation of argumentation formalisms. Arti-
ficial Intelligence, 171, 5-6, 286-310.

CAMINADA, M., HARIKRISHNAN, S., AND SA, S. 2022. Comparing logic programming and formal
argumentation; the case of ideal and eager semantics. Argument & Computation, 13, 1, 93-120.

CAMINADA, M., SA, S., ALCANTARA, J., AND DvoRAK, W. 2015a. On the difference between
assumption-based argumentation and abstract argumentation. [FCoLog Journal of Logic and
its Applications, 2a, 1, 15-34.

CAMINADA, M., SA, S., ALCANTARA, J., AND DvoRAK, W. 2015b. On the equivalence be-
tween logic programming semantics and argumentation semantics. International Journal of
Approximate Reasoning, 58b, 87-111.

CAMINADA, M. AND SCHULZ, C. 2017. On the equivalence between assumption-based argumen-
tation and logic programming. Journal of Artificial Intelligence Research, 60, 779-825.

CAMINADA, M. W. AND GABBAY, D. M. 2009. A logical account of formal argumentation.
Studia Logica, 93, 2-3, 109.

Duna, P. 1995a. An argumentation procedure for disjunctive logic programs. Journal of Logic
Programming, 24a, 151-177.

Dune, P. M. 1995b. On the acceptability of arguments and its fundamental role in nonmono-
tonic reasoning, logic programming and n-person games. Artificial intelligence, 7b, 2, 321—
357.

Dunc, P. M., Kowatsxki, R. A., AND TONI, F. 2009. Assumption-based argumentation. In
Argumentation in artificial intelligence, pp. 199-218. Springer.

DunnE, P. E., DvoRAK, W., LINSBICHLER, T., AND WOLTRAN, S. 2015. Characteristics of
multiple viewpoints in abstract argumentation. Artificial Intelligence, 228, 153-178.

DvorRAkK, W., FANDINNO, J., AND WOLTRAN, S. 2019. On the expressive power of collective
attacks. Argument & Computation, 10, 2, 191-230.

DvorAxk, W., GAGGL, S. A., WALLNER, J. P., AND WOLTRAN, S. 2013. Making use of advances
in answer-set programming for abstract argumentation systems. In Applications of Declarative
Programming and Knowledge Management, pp. 114-133. Springer.

DvorAk, W., RAPBERGER, A., AND WOLTRAN, S. 2023. A claim-centric perspective on abstract
argumentation semantics: Claim-defeat, principles, and expressiveness. Artificial Intelligence,
824, 104011.

EITER, T., LEONE, N., AND SACCA, D. 1997. On the partial semantics for disjunctive deductive
databases. Ann. Math. Artif. Intell., 19, 1-2, 59-96.

FLOURIS, G. AND BIKAKIS, A. 2019. A comprehensive study of argumentation frameworks with
sets of attacking arguments. International Journal of Approximate Reasoning, 109, 55-86.
GOROGIANNIS, N. AND HuNTER, A. 2011. Instantiating abstract argumentation with classical

logic arguments: Postulates and properties. Artificial Intelligence, 175, 9-10, 1479-1497.

Konic, M., RAPBERGER, A., AND ULBRICHT, M. 2022. Just a matter of perspective: Intertrans-
lating expressive argumentation formalisms. In Proc. of the 9th International Conference on
Computational Models of Argument (COMMA), pp. 212-223.

NIELSEN, S. H. AND PARSONS, S. 2006. A generalization of Dung’s abstract framework for
argumentation: Arguing with sets of attacking arguments. In International Workshop on Ar-
gumentation in Multi-Agent Systems, pp. 54-73. Springer.

NIEVES, J. C., CorTEs, U., AND Osorio, M. 2008. Preferred extensions as stable models.
Theory and Practice of Logic Programming, 8, 4, 527-543.

PRZYMUSINSKI, T. 1990. The well-founded semantics coincides with the three-valued stable
semantics. Fundamenta Informaticae, 13, 4, 445-463.


28 J. Alcdntara, R. Cordeiro and S. Sé

RAPBERGER, A. Defining argumentation semantics under a claim-centric view. In STAIRS@
ECAT 2020.

RocuHa, V. H. N. AND CozMAN, F. G. Bipolar argumentation frameworks with explicit con-
clusions: Connecting argumentation and logic programming. In CHKUR Workshop Proceedings
2022a, volume 3197, pp. 49-60. CEUR-WS.

Rocua, V. H. N. AND CozMAN, F. G. A credal least undefined stable semantics for proba-
bilistic logic programs and probabilistic argumentation. In Proceedings of the International
Conference on Principles of Knowledge Representation and Reasoning 2022b, volume 19, pp.
309-319.

SA, S. AND ALCANTARA, J. 2019. Interpretations and models for assumption-based argumen-
tation. In Proceedings of the 34th ACM/SIGAPP Symposium on Applied Computing, pp.
1139-1146.

SA, S. AND ALCANTARA, J. 2021a. An abstract argumentation and logic programming compari-
son based on 5-valued labellings. In Symbolic and Quantitative Approaches to Reasoning with
Uncertainty: 16th European Conference, ECSQARU 2021, pp. 159-172. Springer.

SA, S. AND ALCANTARA, J. 2021b. Assumption-based argumentation is logic programming with
projection. In Symbolic and Quantitative Approaches to Reasoning with Uncertainty: 16th
European Conference, ECSQARU 2021, pp. 173-186. Springer.

SCHULZ, C. AND ToNnI, F. 2015. Logic programming in assumption-based argumentation
revisited-semantics and graphical representation. In 29th AAAI Conf. on Art. Intelligence.

Tonl, F. 2014. A tutorial on assumption-based argumentation. Argument & Computation, 5, 1,
89-117.

Toni, F. AND SERGOT, M. 2011. Argumentation and answer set programming. In Logic pro-
gramming, knowledge representation, and nonmonotonic reasoning, pp. 164-180. Springer.

VERHEIJ, B. 1996. Two approaches to dialectical argumentation: admissible sets and argumen-
tation stages. Proc. NAIC, 96, 357-368.

Wu, Y., CAMINADA, M., AND GABBAyY, D. M. 2009. Complete extensions in argumentation
coincide with 3-valued stable models in logic programming. Studia logica, 93, 2-3, 383.

Appendix A Proofs of Theorems
A.1 Theorems and Proofs from Section [3

Lemma 1
Let P be an NEP, T = (T, F) an interpretation and 0Qp(Z) = (T", F") the least 3-valued
model of ©. It holds

c € T’ iff there exists a statement s constructed from P such that Conc(s) = c and
Vul(s) C F.

c € F" iff for every statement s constructed from P such that Conc(s) = c, we have
Vul(s)NT 40

Proof
Proving that c € T’ iff there exists a statement s constructed from P such that Conc(s) =
cand Vul(s) C F:

= Consider vi! = (T;, F;) for each 2 € N. It suffices to prove by induction on the value
Ds
of i that if c € T;, then there exists a statement s constructed from P such that
Conc(s) = c and Vul(s) C F:

— Basis. For i = 0, the result is trivial as Ty = 0.


On the Equivalence between Logic Programming and SETAF 29

— Step. Assume that for every c’ € T,,, there exists a statement s’ constructed from
P such that Conc(s’) = c! and Vul(s’) C F’. We will prove that if c € T,+1, there
exists a statement s constructed from P such that Conc(s) = c and Vul(s) C F:
If c € Th41, there exists a rule c ¢ a@j,...,@m,not b1,...,not b,(m >
0,n > 0) € P such that {a1,...,a@m} C Tp and {b1,...,0n} C F. It fol-
lows via inductive step that for every 7 € {1,...,m}, there exists a state-
ment s; constructed from P such that Conc(s;) = a; and Vul(s;) C F.
But then, we can construct from P a statement s with Conc(s) = c where
Vul(s) = Vul(s,) U-+-U Vul(s) U {b1,...,6n}. This implies that Vul(s) C F.

< We will prove by structural induction on the construction of statements that for each

statement s constructed from P such that Vul(s) C F’, it holds Conc(s) € T’:

— Basis. Let s be a statement c < not bi,...,not b, (nm > 0) such that
{bi,...,bn} = Vul(s) C F. It follows the fact c€ 4. Then c € 7”.

— Step. Assume $1,...,8m (m > 1) are arbitrary statements constructed from P

such that for each 7 € {1,...,m}, if Vul(s;) C F, then Conc(s;) € T’. We will
prove that if s is a statement c ¢ (s1),...,(S5m),not b1,...,not b, (n > 0)
constructed from P such that Vul(s) C F, then c € T’:
Let s be such a statement. By Definition there exists a rule c <
Q1,.--,Qm,not bj,...,not b, € P such that Conc(s;) = a; for each i €
{1,...,m} and Vul(s) = Vul(s,) U---UVul(s) U {b1,...,b,}. As Vul(s) C F,
we obtain {bi,...,6n} C F and Vul(s;) C F for each i € {1,...,m}. By induc-
tive hypothesis, it follows {a1,...,@m} CT’. Then ce T’.

e Proving that c € F” iff for every statement s constructed from P such that Conc(s) = c,
we have Vul(s) NT # 0:

= Firstly, we will prove by structural induction on the construction of statements that
for each statement s constructed from P such that Vul(s)NT = 9, it holds Conc(s) ¢
EF’;
— Basis. Let s be a statement c < not bi,...,not b, (nm > 0) such that
{bi,...,bn} AT =. It follows the fact c € £ orc“+ueé £. Then c ¢ F’.
— Step. Assume s1,...,8m (m > 1) are arbitrary statements constructed from P
such that for each i € {1,...,m}, if Vul(s;) AT = @, then Conc(s;) ¢ F’. We
will prove that if s is a statement c < (s1),...,(Sm),not b1,...,not by, (n > 0)
constructed from P such that Vul(s) NT = 9, then c ¢ F’:
Let s be such a statement. By Definition [8] there exists a rule c ¢
Q1,.-+,@m,not bj,...,not b, € P such that Conc(s;) = a; for each i €
{1,...,m} and Vul(s) = Vul(s1)U---UVul(s,)U{b1,..., bn}. As Vul(s)NT = 0,
we obtain {bi,...,bn} AT = 90 and Vul(s;) NT = 9 for each i € {1,...,m}. By
inductive hypothesis, it follows {a1,...,@m}MF’ = Q@. Then, c ¢ F’.
Hence, if c € F’, for every statement s constructed from P such that Conc(s) = ¢,
we have Vul(s) NT 4 9.
< Assume that for every statement s constructed from P such that Conc(s) = c, we
have Vul(s) NT #4 @. The proof is by contradiction: suppose that c ¢ F’.


30 J. Alcantara, R. Cordeiro and S. Sd

Consider wt! = (Tj, F;) for each 1 € N. It suffices to prove by induction on the
value of 7 that if c ¢ F;, then there exists a statement s constructed from P such
that Conc(s) =c and Vul(s) NT = 0:

— Basis. For i = 0, the result is trivial as Fp = HBp.

— Step. Assume that for every c’ ¢ F,,, there exists a statement s’ constructed

from P such that Conc(s’) = c’ and Vul(s’) NT = 0. We will prove that if
c¢ Fy+1, there exists a statement s constructed from P such that Conc(s) = c
and Vul(s) NT = 0:
Ifc ¢ Fy41, there exists a rule c + a1,...,@m,not b1,...,not bn(m > 0,n >
0) € P such that {a1,...,dm}A Fy, = 0 and {b1,...,b,} NT = O. It follows
via inductive step that for every 7 € {1,...,m}, there exists a statement s,
constructed from P such that Conc(s;) = a; and Vul(s;) 17 = 9. But then,
we can construct from P a statement s with Conc(s) = c where Vul(s) =
Vul(s,) U-+-UVul(sm) U {b1,...,bn}. This implies that Vul(s) NT = 0.

O
Theorem 3

Let P be an NEP and Ap = (Ap, Attp) be the associated SETAF. For any labelling L
of Ap, it holds Z2Lp(L2Tp(L)) = L.

Proof
Let c € Ap and £2Tp(L) = (T, F); there are three possibilities:

L(c) =in > ceT => T2Lp(L2Tp(L))(c) = in.

e L(c) = out > ce F > T2Lp(L2Tp(L))(c) = out.
e L£(c)=undec > cE TUF = T2£Lp(L2Tp(L))(c) = undec.

O

Theorem 4
Let P be an NEP, Xp = (Ap, Attp) be the associated SETAF and M = (T,F) bea
partial stable model of P. It holds that L2Tp(Z2£p(M)) = M.

Proof
Let M = (T,F) be a partial stable model of P, L2Zp(Z2£p(M)) = (T’, F’) and c €
HB p. It suffices to prove the following results:

ece€TiffceT’.

— Assume c € T. As Dp(M) = M, by Lemma [I] there exists a statement s with
Conc(s) = c such that Vul(s) C F. In particular, it follows that c € Ap. This
implies Z2£p(M)(c) = in and ce T".

— Assume c € T’. Then c € Ap and T2£p(M)(c) = in. From Definition we
obtain ce T.

ecé€Fiffce F’.


On the Equivalence between Logic Programming and SETAF 31

— Assume c ¢ F’. Then c € Ap and Z2£p(M)(c) # out. From Definition [I] we
obtain c ¢ F.

— Assume c ¢ F’. As Qp(M) = M, by Lemma [I] there exists a statement s with
Conc(s) = c such that Vul(s) 0 T = @. In particular, it follows that c € Ap. This
implies Z2£p(M)(c) out andc ¢ F’.

O

Lemma 30
Let P be an NEP, Lp = (Ap, Attp) be the associated SETAF and v € {in, out, undec}.
It holds that

For each B € Att(c), £(b) = v for some b € B iff there exists V € Vul(c) such that
L(b) =v for every bE ApNV.
For each B € Att(c), £(b) # v for some b € B iff there exists V € Vul(c) such that
L(b) # v for every bE ApNV.

Proof
We will prove the result in the first item; the proof of the other result follows a similar
path:

= Assume that for each B € Att(c), £(b) = v for some b € B.

By absurd, suppose that for each V € Vul(c), it holds that £(b) 4 v for some b €E ApNV.
Then we can construct a set B’ C Ap by selecting for each V € Vul(c), an element b € V
such that £(b) 4 v. From Definition [9] we know that there exists B C B’ such that
(B,c) € Attp. But then, there exists B € Att(c) such that £(b) ¥ v for each b € B. It is
absurd as it contradicts our hypothesis.

< Assume that there exists V € Vul(c) such that £(b) = v for every be APNV.

The result is immediate as according to Definition [9] every set B of arguments attacking
c contains an element b€ ApNV.

O

Theorem 5

Let P be an NEP and Ap = (Ap, Attp) be the associated SETAF. It holds
L is a complete labelling of Ap iff L2Zp(L) is a partial stable model of P.
M is a partial stable model of P iff Z2£p(M) is a complete labelling of Ap.

Proof

. If £ is a complete labelling of Ap, then L2Tp(L) is a partial stable model of P:

Let M = £L2Tp(L) = (T,F). We will show M is a partial stable model of P, ice.,
Qp(M) = (T", F’) = (T, F):

e c€T iffc € Ap and L(c) = in iff for each B € Att(c), it holds £(b) = out for
some b € B iff (Lemma[0) there exists V € Vul(c) such that £(b) = out for every
b € Ap NV iff there exists a statement s with Conc(s) = c and Vul(s) C F iff
(Lemmaf[I) c € T’.


32 J. Alcantara, R. Cordeiro and S. Sd

ec¢ F iffc € Ap and L(c) ¥ out iff for each B € Att(c), it holds £(b) ¥ in for
some b € B iff (Lemma [30) there exists V € Vul(c) such that £(b) # in for every
b € Ap nV iff there exists a statement s with Conc(s) = c and Vul(s) NT = 0 iff
(Lemma [I) c ¢ F’.

. If M is a partial stable model of P, then Z2£p(M) is a complete labelling of 2p:

Let M = (T,F) be a partial stable model of P. Then QNp(M) = (T, F). Let c be an
argument in Ap. We will prove £ = Z2£Lp(M) is a complete labelling of Ap:

e L(c) = in iff c € T iff (Lemma[J) there exists a statement s with Conc(s) = c and
Vul(s) C F iff there exists V € Vul(c) such that £(b) = out for every b € ApNV
iff (Lemma OQ) for each B € Att(c), it holds £(b) = out for some b € B.

e L(c) F out iff c ¥ F iff (Lemmaf[]) there exists a statement s with Conc(s) = c and
Vul(s) NT = 0 iff there exists V € Vul(c) such that £(b) 4 in for every b € ApNV
iff (Lemma [O) for each B € Att(c), it holds £(b) 4 in for some b € B.

. If L2Tp(L) is a partial stable model of P, then £ is a complete labelling of Ap:

It holds that £2Zp(L) is a partial stable model of P => according to item [2] above,
T2L p(L2Tp(L)) is a complete labelling of Ap = (via Theorem[3) L is a complete labelling
. If Z2L£p(M) is a complete labelling of 2p, then M is a partial stable model of P:

It holds that Z2£p(M) is a complete labelling of 2p = according to item [I] above,
L2Tp(Z2L p(M)) is a partial stable model of P > (via Theorem[4) M is a partial stable
model of P.

O

Lemma $1
Let P be an NLP, Ap = (Ap, Attp) be its associated SETAF. Let £; and Lz be f-
complete labellings of 2p, and L2Tp(L1) = (TM), Fi) and L2Tp(L2) = (To, Fo). It holds

. in(L,) Cc in(L2) iff T, C Tb.

Proof

1.(=+): Suppose in(£L;) C in(L2). If e € Ti, by Definition [I] c € Ap and L(A) = in.
From our initial assumption, it follows £2(c) = in. So, by Definition ce Tp.

(<=): Suppose T, C T>. If £1(c) = in, by Definition] c € T;. From our initial assump-
tion, it follows c € Tz. So, by Definition [TI] £2(c) = in.

2. It follows directly from point 1.
3. It follows directly from points 1 and 2.

Lemma 382


On the Equivalence between Logic Programming and SETAF 33

Let P be an NLP, Ap = (Ap, Attp) be its associated SETAF. Let £1 and Lz be complete
labellings of Ap, and L2Tp(L 1) = (TM), Fi) and L2Tp(L2) = (To, Fo). It holds

1. out(L1) C out(Le) iff Fy C Fo;
2. out(L)) = out(L2) iff FL = Fy;
3. out(£1) C out(Le) iff Fy C Fp.

Proof

1.(=): Suppose out(L1) C out(Le). If c € Fi, by Definition[Li] there are two possibilities:
e c¢ Ap. As L2Tp(L2) = (To, F2), we obtain that c € Fh.
e c€ Ap and £i(c) = out. From our initial assumption, it follows £2(c) = out.

So, by Definition [I] ¢ € Fy.
(=): Suppose F, C Fy. If £1(c) = out, by Definition [I] c € F,. From our initial
assumption, it follows c € Fy. So, by Definition [TI] £2(c) = out.
2. It follows directly from point 1.
3. It follows directly from points 1 and 2.

O

Lemma 33
Let P be an NLP, Ap = (Ap, Aitp) be its associated SETAF. Let £1 and Lo be complete
labellings of Ap, and L2Tp(L1) = (T), Fi) and L2Tp(L2) = (To, Fo). It holds

1. undec(£,) C undec(L2) iff T; UF, C To U Fa;

2. undec(L1) = undec(L2) iff 7) U Fy = T2 U Fo;
3. undec(L,) C undec(Lo) iff 7) UF, C T2 U Fo.

Proof

1.(=): Suppose undec(L1) C undec(L2). If c € T; U Fj, by Definition [T]] c € Ap and
£1(c) = undec. From our initial assumption, it follows £2(c) = undec. So, by
Definition [1] c € Ty U F5.
(<): Suppose 7, U Fy C Ty U Fy. If £1(c) = undec, by Definition] c € T; UF). From
our initial assumption, it follows c € T> U F2. So, by Definition[T]] £2(c) = undec.
2. It follows directly from point 1.
3. It follows directly from points 1 and 2.

Theorem 6
Let P be an NEP and Ip = (Ap, Attp) be the associated SETAF. It holds

. £ is a grounded labelling of 2p iff £L2Zp(L) is a well-founded model of P.
. Lisa preferred labelling of Ap iff L2Tp(L) is a regular model of P.

. Lisa stable labelling of Ap iff L2Tp(L) is a stable model of P.

. Lis asemi-stable labelling of Ap iff L2Zp(L) is an L-stable model of P.

ePwn re


Pw hNY

34 J. Alcantara, R. Cordeiro and S. Sd

Proof
Let £ be an argument labelling of %p and L2Tp(L) = (T, F). The proof is straightfor-
ward:

. £is a grounded labelling of 2p iff £ is a complete labelling of 2p, and in(L) is minimal

(w.r.t. set inclusion) among all complete labellings of Ap iff (Theorem[5Jand LemmaBI)
£L2Tp(L) is a partial stable model of P, and there is no partial stable model M’ = (T’, F’)
of P such that T’ C T iff £L2Zp(L) is a well-founded model of P;

. Lis a preferred labelling of 2p iff £ is a complete labelling of &p, and in(L) is maximal

(w.r.t. set inclusion) among all complete labellings of Ap iff (Theorem[]and Lemma)
£L2Tp(L) is a partial stable model of P, and there is no partial stable model M’ = (T’, F’)
of P such that T C T" iff £L2Zp(L) is a regular model of P;

. £is a stable labelling of 2p iff L is a complete labelling of 2p such that undec(L) = 0
a

iff (Theorem [5) £2Tp(L) is a partial stable model such that TU F = @ iff L2Tp(L) is
stable model of P;

. £ is a semi-stable labelling of 2p iff £ is a complete labelling of Ap, and undec(L) is

minimal (w.r.t. set inclusion) among all complete labellings of 2p iff (Theorem [5] and
Lemma[33) £2Tp(L) is a partial stable model of P, and there is no partial stable model
M' = (T', F’) of P such that T’N F’ C TUF iff L2Tp(L) is an L-stable model of P.

O

Corollary 7
Let P be an NEP and Ap = (Ap, Attp) be the associated SETAF. It holds

. M is a well-founded model of P iff Z2£p(M) is a grounded labelling of Ap.
. M is a regular model of P iff Z2£p(M) is a preferred labelling of Ap.

. M is a stable model of P iff Z2£p(M) is a stable labelling of Ap.

. M is an L-stable model of P iff Z2£p(M) is a semi-stable labelling of 2p.

Proof
These results come from Theorems [4] and [6] oO

A.2 Theorems and Proofs from Section [4]

Theorem &
Let 2 = (A, Att) be a SETAF and Py its associated NLP.

For any labelling £ of 21, it holds Z2Ly(L2Zq(L)) = L.
For any interpretation Z of Py, it holds £L2Tq(Z2L£Ly(Z)) = T.

Proof
Both results are immediate:

Proving that for any labelling C of 2, it holds T2Ly(L2Ty(L)) = L:
Let £L2Ty(L) = (T, F).
— La) =inSa€T > T2Ly(L2Ty(L))(a) = in;
L(a) = out > ac F > T2Ly(L2Ty(L))(a) = out;



On the Equivalence between Logic Programming and SETAF 35

— L(a) =undec > AC TUF = T2Ly(L2Ty(L))(a) = undec.

e Proving that for any interpretation Z of Py, it holds £2Tq(Z2L£Ly(Z)) = T.
Let Z = (T, F) be an interpretation of Py, and £L2Ty(Z2Lq(Z)) = (T’, F’). We will show
T=T' and F= F’:

—aceTsT2Lly(Z)(a)=insaeT’;
— a€ F > 72Lq(Z)(a) = out > aE F’;
— a€ TUF = T2Ly(Z)(a) = undec > aE T’UF’;

Theorem 9
Let 2 be a SETAF and Py be its associated NLP. It holds

£ is a complete labelling of 2 iff L2Zq(L) is a partial stable model of Py.
M is a partial stable model of Py iff T2L4(M) is a complete labelling of 2.

Proof

1. Proving that if £ is a complete labelling of 2, then £2Zy(L) is a partial stable model of
Py:
Let £L2Zy(L) = (T,F) and Op, (£L2Tq(L)) = (T’, F’). It suffices to show L2Ty(L) is a
fixpoint of Qp,: T = T’ and F = F”. For any argument a € A = HBp,, there are three
possibilities:

e a€T. Then L(a) = in. From Definition 2] we know that for each B € Att(a), it
holds £(b) = out for some b € B. It follows from Definition [12] that there exists
V € Yq such that £(b) = out for every b € V. This means the fact a € mee
ie, aE T".

e a€ F. Then L(a) = out. From Definition 2] we know that there exists B € Att(a)
such that £(b) = in for each b € B. It follows from Definition [2] that for each
V € Va, there exists b € V such that £(b) = in. This means that there exists no

. 2 . )
rule for a in D2Ta(L)’ Le. ae BF".

e a€ TUF. Then L(a) = undec. From Definition [2] we know that (i) there exists
B € Att(a) such that £(b) A out for each b € B, and (ii) for each B € Att(a), it
holds £(b) # in for some b € B. It follows from Definition [12] that (i) there does
not exist V € V, such that £(b) = out for every b € V, and (ii) there exists V € Va

P
such that £(b) # in for each b € V. This means (i) the fact a > and (ii)
L2T(L)
P; PB,
there exists rule for a in PE Thus body(r) = u for any r € eta) such

that head(r) = a, i.e., a € T’ UF”.

2. Proving that if M is a partial stable model of Py, then Z2£(M) is a complete labelling
of 2:
Let M = (T,F) be a partial stable model of Py. Thus M is a fixpoint of Qp,, ie.,
Qp,(M) = M. We now prove Z2£Ly(M) is a complete labelling of 2. For any a €
HB p, = A, there are three possibilities:


Pr wn e

36 J. Alcantara, R. Cordeiro and S. Sd

e T2Ly(M)(a) = in. Then a € T. As Qp,(M) = M, the fact a € a This
means that there exists a rule a ¢ not by,...,not b, € Py (n > 0) such that
{bi,...,6n} C F. It follows from Definition [2] that for each B € Ait(a), it holds
T2Ly(M)(b) = out for some b € B;

T2Ly(M)(a) = out. Then a € F. As Op, (M) = M, there exists no rule for a in
ri This means that for every rule a ¢ not bi,...,not b, € Py (n > 0), there
exists b; € T (1 <i <n). It follows from Definition [12] that there exists B € Att(a)
such that Z2£q(M)(b) = in for each b € B;

—_—__ P;
T2L£Ly(M)(a) = undec. Then a € TUF. As Qp,(M) = M, the fact a ¢ va but

there exists a rule r in fa such that head(r) = a and body(r) = u. This means
that (i) for each rule a + not bj,...,not bp € Py (n > 0), it holds {bi,...,6n} Z
F, and (ii) there exists a rule a < not bj,...,not b, € Py (n > 0) such that
{bi,...,bn} AT = 0. It follows from Definition [[2]that (i) there exists B € Att(a)
such that Z2£y(M)(b) 4 out for each b € B, and (ii) for each B € Att(a), it holds
T2Ly(M)(b) # in for some b € B.

Hence, Z2Ly(M) is a complete labelling of 2.

. Proving that if £2Zq(L) is a partial stable model of Py, then £ is a complete labelling

of 2:
£L2Ty(L) is a partial stable model of Py = according to item 2] above, T2Ly (L2Ty(L))
is a complete labelling of 21 = (Theorem[8) £ is a complete labelling of 2.

. Proving that if Z2£y(M) is a complete labelling of 21, then M is a partial stable model

of Py:
T2Ly(M) is complete labelling of 2% = according to item L] above, L2Ty(Z2Ly(M)) is
a partial stable model of Py = (Theorem[8) M is a partial stable model of Py.

O

Theorem 10
Let 2 be a SETAF and Py its associated NLP. It holds

. £ is a grounded labelling of 2 iff £2Zy(L) is a well-founded model of Py.
. £is a preferred labelling of 2 iff L2Zy(L) is a regular model of Py.

. Lis a stable labelling of 2 iff L2Zy(L) is a stable model of Py.

. £ is a semi-stable labelling of 2 iff £2Zq(L) is an L-stable model of Py.

Proof
Let £ be an argument labelling of 2. Recall that £2Zy(L) = (in(L), out(L)). The proof
is straightforward:

. £ is a grounded labelling of 2 iff £ is a complete labelling of 2 and in(L) is minimal

(w.r.t. set inclusion) among all complete labellings of 2 iff (Theorem [9) £L2Zy(L) is a
partial stable model of Py and there is no partial stable model M’ = (T’, F’) of Py such
that T’ C in(L) iff L2Zq(L) is a well-founded model of Py;

. £ is a preferred labelling of 2 iff £ is a complete labelling of 2% and in(L) is maximal

(w.r.t. set inclusion) among all complete labellings of 2 iff (Theorem [9) £L2Zy(L) is a


ewrere

. Lis a stable labelling of 2 iff £ is a complete labelling of 2 such that undec(L) =

On the Equivalence between Logic Programming and SETAF 37

partial stable model of Py and there is no partial stable model M' = (T’, F’) of P such
that in(L) C T’ iff L2Zy(L) is a regular model of Py;

0 iff
(Theorem [9) £2Zq(L) is a partial stable model of Py such that in(£) U out(L) = 0 iff
L2Ty(L) is a stable model of Py;

i

. Lis asemi-stable labelling of 2 iff £ is a complete labelling of 2( and undec(L) is minimal

(w.r.t. set inclusion) among all complete labellings of 2 iff (Theorem [9) £L2Zy(L) is a
partial stable model of Py and there is no partial stable model M’ = (T’, F") of Py such
that T’U F’ C in(L) Uout(L) iff £2Zy(L) is an L-stable model of Py.

O

Corollary 11
Let 2 be a SETAF and Py its associated NLP. It holds

. M is a well-founded model of Py iff Z2£y(M) is a grounded labelling of Q.
. M is a regular model of Py iff Z2£Lq(M) is a preferred labelling of 2.

. M is a stable model of Py iff Z2£Ly(M) is a stable labelling of 2.

. M is an L-stable model of Py iff Z2£Lq(M) is a semi-stable labelling of 2.

Proof
These results come from Theorems]§] and [10] |

A.3 Theorems and Proofs from Section [5]

Proposition 12
Let 2 = (A, Att) be a SETAF and Py its associated NEP. It holds Py is an RFALP.

Proof
It follows that
. Each rule in Py has the form a «+ not }1,...,not bn;
. for each rule a ¢ not by,...,not b, € Py, if b © {b1,..., bn}, there exists (B,a) € Att

such that b € B, ie,. b € Ap. Then there exists a rule r € Py such that b = head(r).
This suffices to guarantee HB p, = {head(r) | r € Py};

. Arule a + not bj,...,not b, € Py iff there exists a minimal set (w.r.t. set inclusion)

V = {b,...,b,} such that for each B € Att(a), there exists b € BN V. This means there
exists no rule a + not c1,...,not Cy € Py such that {c1,...,¢n7} C {bi,..., dn}.

Hence, Py is an RFALP. |

Lemma 34
Let P be an RFALP, Headp = {head(r) | r € P} and Ap = (Ap, Attp) its corresponding
SETAF. It holds Headp = Ap.

Proof
The result is straightforward: c € Head p iff there exists arule c + not b),...,not b, € P
(n > 0) iff c € Ap (Definition [). O


38 J. Alcdntara, R. Cordeiro and S. Sé

Theorem 13
Let 2 = (A, Att) be a SETAF, Py its associated NEP and 2p, the associated SETAF
of Py. It holds that 21 = Ap, .

Proof
Let 2 = (A, Att) be a SETAF with A = {aj,...,a,} and for each a; € A, we define
R; = {r € Py | head(r) = aj}, ie., Py = Ry UR2U---U Ry. It follows from Proposition
[12] and Lemma [34] that Ap, = (Ap, Attp,) with Ap, = {a1,...,an} = A. It remains
to prove that Att = Attp,:

(B,a;) € Att iff (B,a;) € Att and there exists no B’ C B such that (B’,a;) € Att iff B
is a minimal set (w. r. t. set inclusion) in which for each rule r € R,, there exists b c B
such that not b € body (r) iff B is a minimal set (w. r. t. set inclusion) in which for each

V € Vul(a;), there exists b € BNV iff (B,a;) € Attp,. O
Lemma 35

Let P be an RFALP, Ap = (Ap, Attp) the corresponding SETAF and c € Ap. If
{a1,...,;@n} is a minimal set such that for each B € Attp(c), there exists a; € B (1 <
i<n), then c+ not aj,...,not a, € P.

Proof

As for each B € Attp(c), there exists a; € B (1 <i <n), it follows from Definition []
that there exists V € Vul(c) such that V C {a1,...,@n}. Note that for each B € Attp(c),
there exists b € VOB. As {a1,...,@n} is a minimal set with this property, it holds
V = {a1,...,@n}. Then (Definition B) c + not aj,...,not an € P. oO

Theorem 14
Let P be an RFALP, Ap its associated SETAF and Py, the associated NEP of Ap. It
holds that P = Py,.

Proof

Let P be an RFALP with HBp = {a,...,a,}, and Ap = (Ap, Attp) the corresponding
SETAF. For each a; € HBp (1 < i < n), we define R; = {r € Py | head(r) = a;}. It
follows that Ap = {a1,...,@n}. Hence, HBp,, = {a1,.--,@n}. We will prove P = Py,:

Ifa; + not aj;,,...,not a;,, € P. then a; € Ap and {a;,,...,a;,, } is a minimal set (w.r.t.
set inclusion) such that for each B € Attp(a;), there exists a;, € B (k € {1,...,m}).
This implies (Definition [I2) a; < not aj;,,...,not ai,, € Pap.
If a; < not aj,,...,nota;,, € Py,, then (Definition {ai,,;---,@i,,} is a minimal
set (w.r.t. set inclusion) such that for each B € Attp(a;), there exists a;, € B (k €
{1,...,m}). Thus (Lemma|[35) a; < not aj,,...,not a;,, € P.

O

A.4 Theorems and Proofs from Section [6
Theorem 15


On the Equivalence between Logic Programming and SETAF 39

The relation + yrpy is strongly terminating for fair sequences of program transforma-
tions, i.e., such fair sequences always lead to irreducible programs.

Proof

Let Pi burpm Po '+urem ++: turepm Pe Pt urem +: Purem Py -urpm ::: bea fair
sequence of ++yrpy. This fairness condition implies that for every atom a, there exists
a natural number k such that for each NEP P; with i > k in the sequence of + yurpy
above, it holds a ¢ body*(r) for each r € P;. As each NLP is a finite set of rules, from
some natural number k’ on, body*(r) = @ for any r € Py. Then for each k” > k’, Oy
and ++, cannot be applied in Pi. It remains the program transformations > p and yy.
For each of these P,, there are two possibilities:

+x strictly decreases the number of rules of Py or
++p strictly decreases the number of negative literals in body” (r) for some r € Py.

It follows that the successive application of +), or +p in these Pys will eventually
lead to an irreducible NLP. O

Theorem 16
For any NLP P, there exists an irreducible NLP P* such that P++7ppyy P*.

Proof
A simple method to obtain a fair sequence of program transformations with respect to
+uTpm is to apply +y to arule r only if +7 is not applicable to r and to ensure that
whenever +>z, has been applied to get rid of an occurrence of an atom a, then all such
occurrences of a (in other rules of the same program) have also been removed before
applying ++y to another occurrence of an atom b # a.

As for any NLP P, it is always possible to build such a fair sequence of program
transformations with respect to +> ypu, we obtain from Theorem [15] that there exists
an irreducible NEP P* such that P (7yppyy P*. O

Theorem 17

Let P be an NEP and P* be an NEP obtained after applying repeatedly the program
transformation ++ yrpy until no further transformation is possible, i.e., P -%ppyy, P*
and P* is irreducible. Then P* is an RFALP.

Proof
To prove it by contradiction, suppose P* is not an RFALP. There are three possibilities:

A rule c¢ @y,...,@m,not b1,...,not b, € P* with m > 1 and n> 0. Then

— The program transformation ++y (unfolding) can be applied.
— Ifc € {a1,...,a@m}, the program transformation ++7 (elimination of tautologies)
can be applied.

A rule c ¢ not bj,...,not b, € P*, but there exists b € {b1,...,b,} such that b ¢
{head(r) |r € P*}. Then the program transformation +p (positive reduction) can be
applied.


40 J. Alcdntara, R. Cordeiro and S. Sé

A rule c + not bj,...,not b, € P* and there is a rule c + not cj,...,not cp € P* such
that {c1,...,¢p} C {b1,...,6n}. Then the program transformation ++, (elimination of
non-minimal rules) can be applied.

It is absurd as in each case, there is still a program transformation to be applied. O

Theorem 18
Let P be an RFALP. Then P is irreducible with respect to ( yrpy.

Proof
Let P be an RFALP. It holds

The program transformations ++y and +7 cannot be applied as they require a rule
C+ Q41,.--,4m,not bj,...,not b, in P with m > 1.

The program transformation +p cannot be applied as it requires a rule c <
@1,---,@m,not b,not bj,...,not b, in P such that b ¢ {head(r)|reP}, but
{head(r) |r € P} = HBp.

The program transformation ++>,, cannot be applied as it requires two distinct rules r
and r’ in P such that head(r) = head(r’) and body™ (r’) C body (r).

O

Theorem 21
Let P, and Py be NEPs such that P; +>7 Pp». It holds M is a partial stable model of P;
iff M is a partial stable model of Pp.

Proof

Let Po = P, — {r} and head(r) € bodyt(r). We have to show for any interpretation
M = (T,F), it holds M is a partial stable model of P; iff M is a partial stable model
of Pj; we distinguish two cases:

{a | not a € body (r)} NT #0: Then a = =. This trivially implies that M is a partial
stable model of P, iff it is a partial stable model of P.

{a | not a € body" (r)} AT = 0: Then it is clear a Hr =. As both a and & are
positive programs, according to Lemmaf[19] it holds M is the least model of a iff M is
the least model of &. Hence, M is a partial stable model of P, iff it is a partial stable

model of P».
O
Theorem 22

Let P, and P; be NEPs such that P, +>p P,. It holds M is a partial stable model of P,
iff M is a partial stable model of Pp.

Proof
Let

Pp =P, — {c+ a,...,@m,not b,not b),...,not by}

Uf{ee ay,...,@m,not b1,...,not by}


On the Equivalence between Logic Programming and SETAF Al

such that r is the rule c ¢€ aj,...,@m,not b,not bj,...,notb, € Py and b ¢
{head(r’) | r’ € P,}. We have to show that for any interpretation M = (T,F), it holds
M is a partial stable model of P,; iff M is a partial stable model of P; we distinguish
two cases:

({a | not a € body” (r)} — {b}) IT £0 or b € F: Then a = 4%. This trivially implies
that M is a partial stable model of P, iff it is a partial stable model of Py.

({a | not a € body” (r)} — {b}) NT =0 and b ¢ F. Let (1), F\) and (To, Fy) be respec-
tively the least models of a and 2. As b Z {head(r’) |r’ € Pi}, it is clear that b € Fy
and b € Fy. Given that b ¢ F,, we obtain M = (T, F) is different from both (71, F,) and
(To, Fy). Hence, M is neither a partial stable model of P, nor of P2. This implies that
M is a partial stable model of P, iff it is a partial stable model of Po.

O

Theorem 23
Let P, and P, be NIPs such that P; +>,4 Pp. It holds M is a partial stable model of P;
iff M is a partial stable model of Pp.

Proof

Suppose that there are two distinct rules r and r’ in P, such that head(r) = head(r’),
body* (r’) C body* (r), body™ (r’) © body~ (r) and P, = P, — {r}. We have to show that
for any interpretation M = (T, F), it holds that M is a partial stable model of P; iff M
is a partial stable model of P2; we distinguish two cases:

{a | not a € body (r)} NT 4 0 or ({a| not a € body (r)} NT = 0 and body*(r) =
body (r’)): Then a = ve This trivially implies that M is a partial stable model of P;
iff it is a partial stable model of P.

{a | not a € body (r)} AT =0 and body* (r’) C body* (r): Then it is clear that a HM
ie As both a and ie are positive programs, according to Lemma[LJ] it holds that M
is the least model of a iff M is least model &. Hence, M is a partial stable model of

P, iff it is a partial stable model of P2.
O

Theorem 24
Let P be an NEP and P* be an irreducible NEP such that P +7,ppy, P*. It holds M is
a partial stable model of P iff M is a partial stable model of P*.

Proof

If P +7;ppy P*, then there exists a finite sequence of program transformations P =

Pi burem ++: BM urem Py, = P*. According to Theorems 20} 21) 22] and 23] M is a

partial stable model of P; iff M is a partial stable model of Pj41 with 1 <i <n. Thus

by transitivity, M is a partial stable model of P iff M is a partial stable model of P*.
O

Corollary 25


42 J. Alcdntara, R. Cordeiro and S. Sé

Let P be an NEP and P* be an irreducible NEP such that P -7,ppy, P*. It holds M is
a well-founded, regular, stable, D-stable model of P iff M is respectively a well-founded,
regular, stable, L-stable model of P*.

Proof
As P and P* share the same set of partial stable models (Theorem 24), the result is
straightforward. O

Corollary 26

For any NLP P, there exists an RFALP P* such that M is a partial stable, well-founded,
regular, stable, L-stable model of P iff M is respectively a partial stable, well-founded,
regular, stable, L-stable model of P*.

Proof

From Theorem [16] we know that for any NEP P, there exists an irreducible NEP P*
such that P +7, ppy, P*. From Theorem [17] we obtain P* is an RFALP. Besides, from
TheoremP4Jand Corollary[25] we infer M is a partial stable, well-founded, regular, stable,
L-stable model of P iff M is respectively a partial stable, well-founded, regular, stable,
L-stable model of P*. O

Theorem 27
NLIPs and RFALPs have the same expressiveness for partial stable, well-founded, regular,
stable, and L-stable semantics.

Proof
We have

For any NLP P, there exists an RFALP P* such that M is a partial stable, well-founded,
regular, stable, L-stable model of P iff M is respectively a partial stable, well-founded,
regular, stable, L-stable model of P* (Corollary 26).

Obviously, any RFALP is an NLP.

Hence, NZPs and RFALPs have the same expressiveness for partial stable, well-
founded, regular, stable and L-stable semantics. oO

Lemma 36
Let P, and Py be NEPs such that Pj +y Pp». It holds that 2p, = Ap,.

Proof
Let P, and P, be NLPs such that
Pp =P, — {ec a, 41,...,Am,not by,...,not b,}
Uf{ee yon s play Oty wx + pillemy hb bi, .-.;not bi, not by,..., not by, |
a+ aj,...,@,,not bi,...,not bi, € Pi},

Ap, = (Ap, , Attp, ) and Ap, = (Ap,, Attp,). Note that

For each statement s € Gp,, there exists s’ € Gp, such that Conc(s) = Conc(s’), and
Vul(s) = Vul(s’).


On the Equivalence between Logic Programming and SETAF 43

For each statement s’ € Gp,, there exists s € Gp, such that Conc(s’) = Conc(s), and
Vul(s’) = Vul(s).

Hence, Ap, = Ap,, and Attp, = Attp,. O

Lemma 87
Let P, and Py be NEPs such that P; +r P. It holds that Ap, = Ap,.

Proof

Let Py = P, — {r}, where there exists a rule r € P, such that head(r) € bodyt(r). In
addition, let %p, = (Ap,, Attp,) and Ap, = (Ap,, Attp,). Note that

For each statement s € Gp,, there exists s’ € Gp, such that Conc(s) = Conc(s’), and for
each V € Vul(s), there exists V’ € Vul(s) 7 Vul(s’) such that V’ CV.

For each statement s’ € Gp,, there exists s € Gp, such that Conc(s’) = Conc(s), and
Vul(s’) = Vul(s).

Hence, Ap, = Ap,, and for each c € Ap,, V is a minimal set (w.r.t. set inclusion) in
Vulp, (c) iff V is a minimal set (w.r.t. set inclusion) in Vulp,(c); it holds that Attp, =
Attp,. oO

Lemma 38
Let P, and Py be NEPs such that P; +p P2. It holds that 2p, = Ap,.

Proof
Let ¢ © 4j,..-,@m,not b,not bj,...,not b, € Py, be a rule such that b ¢
{head(r) |r € Py},

Pp =(P, — {cH a),...,@m,not b,not b1,...,not b,})

Uf{ee ar,...,@m,not b1,...,not bn},
Ap, = (Ap,, Attp, ) and Ap, = (Ap,, Aitp,). Note that

For each statement s € Gp,, there exists s’ € Gp, such that Conc(s) = Conc(s’), and
Vul(s) = {V | dV’ € Vul(s’) such that V = V’ or V=V'U {dh}.
For each statement s’ € Gp,, there exists s € Gp, such that Conc(s’) = Conc(s), and
Vul(s’) = {V’ | dV € Vul(s) such that V’=V or V’ = V — {b}}.

Hence, Ap, = Ap,, and as b ¢ Ap, U Ap,, it holds that Alttp, = Attp,. O

Lemma 39
Let P, and P2 be NEPs such that P; >), P2. It holds that 2p, = Ap,.

Proof

Let P2 = P, — {r}, where there are two distinct rules r and r’ in P, such that
head(r) = head(r’), body*(r’) CG bodyt(r), body~(r') C body~(r). In addition, let
Ap, = (Ap,, Attp,) and Ap, = (Ap,, Attp,). Note that

For each statement s € Gp,, there exists s’ € Gp, such that Conc(s) = Conc(s’), and for
each V € Vul(s), there exists V’ € Vul(s) M Vul(s’) such that V’ CV.


44 J. Alcdntara, R. Cordeiro and S. Sé

For each statement s’ € Gp,, there exists s € Gp, such that Conc(s’) = Conc(s), and
Vul(s’) = Vul(s).

Hence, Ap, = Ap,, and for each c € Ap,, V is a minimal set (w.r.t. set inclusion) in
Vulp, (c) iff V is a minimal set (w.r.t. set inclusion) in Vulp,(c); it holds that Attp, =
Attp,. oO

Theorem 28
For any NLIPs Py and Pp, if Py >UTPM Po, then Ap, = Ap,

Proof
It follows straightforwardly from Lemmas and Oo
Theorem 29

The relation ++ yrpwm is confluent, i.e., for any NLPs P, P’ and P”, if Prot ppyy P’ and
PHyrpm P" and both P’ and P” are irreducible, then P’ = P”.

Proof
From Theorem 28] we know that %p = Ap = Ap. Thus Py,, = Py,,,. As P’ and P”
are RFALPs (Theorem[I7), it holds (Theorem [I4) that P’ = Py,, = Py,,, = P”. |

